!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):(t=t||self).ConstrainoDelaunato=s()}(this,(function(){"use strict";const t=Math.pow(2,-52),s=new Uint32Array(512);class o{static from(t,s=a,n=u){const e=t.length,i=new Float64Array(2*e);for(let o=0;o<e;o++){const e=t[o];i[2*o]=s(e),i[2*o+1]=n(e)}return new o(i)}constructor(t){const s=t.length>>1;if(s>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;const o=Math.max(2*s-5,0);this._triangles=new Uint32Array(3*o),this._halfedges=new Int32Array(3*o),this._hashSize=Math.ceil(Math.sqrt(s)),this._hullPrev=new Uint32Array(s),this._hullNext=new Uint32Array(s),this._hullTri=new Uint32Array(s),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(s),this._dists=new Float64Array(s),this.update()}update(){const{coords:s,_hullPrev:o,_hullNext:e,_hullTri:r,_hullHash:c}=this,a=s.length>>1;let u=1/0,d=1/0,f=-1/0,g=-1/0;for(let t=0;t<a;t++){const o=s[2*t],n=s[2*t+1];o<u&&(u=o),n<d&&(d=n),o>f&&(f=o),n>g&&(g=n),this._ids[t]=t}const y=(u+f)/2,x=(d+g)/2;let _,p,b,M=1/0;for(let t=0;t<a;t++){const o=n(y,x,s[2*t],s[2*t+1]);o<M&&(_=t,M=o)}const w=s[2*_],A=s[2*_+1];M=1/0;for(let t=0;t<a;t++){if(t===_)continue;const o=n(w,A,s[2*t],s[2*t+1]);o<M&&o>0&&(p=t,M=o)}let k=s[2*p],m=s[2*p+1],S=1/0;for(let t=0;t<a;t++){if(t===_||t===p)continue;const o=h(w,A,k,m,s[2*t],s[2*t+1]);o<S&&(b=t,S=o)}let v=s[2*b],L=s[2*b+1];if(S===1/0){for(let t=0;t<a;t++)this._dists[t]=s[2*t]-s[0]||s[2*t+1]-s[1];l(this._ids,this._dists,0,a-1);const t=new Uint32Array(a);let o=0;for(let s=0,n=-1/0;s<a;s++){const e=this._ids[s];this._dists[e]>n&&(t[o++]=e,n=this._dists[e])}return this.hull=t.subarray(0,o),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(i(w,A,k,m,v,L)){const t=p,s=k,o=m;p=b,k=v,m=L,b=t,v=s,L=o}const P=function(t,s,o,n,e,i){const r=o-t,h=n-s,l=e-t,c=i-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l);return{x:t+(c*a-h*u)*d,y:s+(r*u-l*a)*d}}(w,A,k,m,v,L);this._cx=P.x,this._cy=P.y;for(let t=0;t<a;t++)this._dists[t]=n(s[2*t],s[2*t+1],P.x,P.y);l(this._ids,this._dists,0,a-1),this._hullStart=_;let I=3;e[_]=o[b]=p,e[p]=o[_]=b,e[b]=o[p]=_,r[_]=0,r[p]=1,r[b]=2,c.fill(-1),c[this._hashKey(w,A)]=_,c[this._hashKey(k,m)]=p,c[this._hashKey(v,L)]=b,this.trianglesLen=0,this._addTriangle(_,p,b,-1,-1,-1);for(let n,h,l=0;l<this._ids.length;l++){const a=this._ids[l],u=s[2*a],d=s[2*a+1];if(l>0&&Math.abs(u-n)<=t&&Math.abs(d-h)<=t)continue;if(n=u,h=d,a===_||a===p||a===b)continue;let f=0;for(let t=0,s=this._hashKey(u,d);t<this._hashSize&&(f=c[(s+t)%this._hashSize],-1===f||f===e[f]);t++);f=o[f];let g,y=f;for(;g=e[y],!i(u,d,s[2*y],s[2*y+1],s[2*g],s[2*g+1]);)if(y=g,y===f){y=-1;break}if(-1===y)continue;let x=this._addTriangle(y,a,e[y],-1,-1,r[y]);r[a]=this._legalize(x+2),r[y]=x,I++;let M=e[y];for(;g=e[M],i(u,d,s[2*M],s[2*M+1],s[2*g],s[2*g+1]);)x=this._addTriangle(M,a,g,r[a],-1,r[M]),r[a]=this._legalize(x+2),e[M]=M,I--,M=g;if(y===f)for(;g=o[y],i(u,d,s[2*g],s[2*g+1],s[2*y],s[2*y+1]);)x=this._addTriangle(g,a,y,-1,r[y],r[g]),this._legalize(x+2),r[g]=x,e[y]=y,I--,y=g;this._hullStart=o[a]=y,e[y]=o[M]=a,e[a]=M,c[this._hashKey(u,d)]=a,c[this._hashKey(s[2*y],s[2*y+1])]=y}this.hull=new Uint32Array(I);for(let t=0,s=this._hullStart;t<I;t++)this.hull[t]=s,s=e[s];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,s){return Math.floor(function(t,s){const o=t/(Math.abs(t)+Math.abs(s));return(s>0?3-o:1+o)/4}(t-this._cx,s-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:o,_halfedges:n,coords:e}=this;let i=0,h=0;for(;;){const l=n[t],c=t-t%3;if(h=c+(t+2)%3,-1===l){if(0===i)break;t=s[--i];continue}const a=l-l%3,u=c+(t+1)%3,d=a+(l+2)%3,f=o[h],g=o[t],y=o[u],x=o[d];if(r(e[2*f],e[2*f+1],e[2*g],e[2*g+1],e[2*y],e[2*y+1],e[2*x],e[2*x+1])){o[t]=x,o[l]=f;const e=n[d];if(-1===e){let s=this._hullStart;do{if(this._hullTri[s]===d){this._hullTri[s]=t;break}s=this._hullPrev[s]}while(s!==this._hullStart)}this._link(t,e),this._link(l,n[h]),this._link(h,d);const r=a+(l+1)%3;i<s.length&&(s[i++]=r)}else{if(0===i)break;t=s[--i]}}return h}_link(t,s){this._halfedges[t]=s,-1!==s&&(this._halfedges[s]=t)}_addTriangle(t,s,o,n,e,i){const r=this.trianglesLen;return this._triangles[r]=t,this._triangles[r+1]=s,this._triangles[r+2]=o,this._link(r,n),this._link(r+1,e),this._link(r+2,i),this.trianglesLen+=3,r}}function n(t,s,o,n){const e=t-o,i=s-n;return e*e+i*i}function e(t,s,o,n,e,i){const r=(n-s)*(e-t),h=(o-t)*(i-s);return Math.abs(r-h)>=33306690738754716e-32*Math.abs(r+h)?r-h:0}function i(t,s,o,n,i,r){return(e(i,r,t,s,o,n)||e(t,s,o,n,i,r)||e(o,n,i,r,t,s))<0}function r(t,s,o,n,e,i,r,h){const l=t-r,c=s-h,a=o-r,u=n-h,d=e-r,f=i-h,g=a*a+u*u,y=d*d+f*f;return l*(u*y-g*f)-c*(a*y-g*d)+(l*l+c*c)*(a*f-u*d)<0}function h(t,s,o,n,e,i){const r=o-t,h=n-s,l=e-t,c=i-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l),f=(c*a-h*u)*d,g=(r*u-l*a)*d;return f*f+g*g}function l(t,s,o,n){if(n-o<=20)for(let e=o+1;e<=n;e++){const n=t[e],i=s[n];let r=e-1;for(;r>=o&&s[t[r]]>i;)t[r+1]=t[r--];t[r+1]=n}else{let e=o+1,i=n;c(t,o+n>>1,e),s[t[o]]>s[t[n]]&&c(t,o,n),s[t[e]]>s[t[n]]&&c(t,e,n),s[t[o]]>s[t[e]]&&c(t,o,e);const r=t[e],h=s[r];for(;;){do{e++}while(s[t[e]]<h);do{i--}while(s[t[i]]>h);if(i<e)break;c(t,e,i)}t[o+1]=t[i],t[i]=r,n-e+1>=i-o?(l(t,s,e,n),l(t,s,o,i-1)):(l(t,s,o,i-1),l(t,s,e,n))}}function c(t,s,o){const n=t[s];t[s]=t[o],t[o]=n}function a(t){return t[0]}function u(t){return t[1]}var d;function f(t){return t%3==2?t-2:t+1}function g(t,s,o=!1){const n=(s.y1-s.y0)*(t.x1-t.x0)-(s.x1-s.x0)*(t.y1-t.y0);if(0===n)return{x:1/0,y:1/0};let e=t.y0-s.y0,i=t.x0-s.x0;const r=(s.x1-s.x0)*e-(s.y1-s.y0)*i,h=(t.x1-t.x0)*e-(t.y1-t.y0)*i;e=r/n,i=h/n;const l={x:t.x0+e*(t.x1-t.x0),y:t.y0+e*(t.y1-t.y0)};let c=function(t,s){const o={a:!1,b:!1};t>0&&t<1&&(o.a=!0);s>0&&s<1&&(o.b=!0);return o}(e,i);return o&&(c=function(t,s){const o={a:!1,b:!1};t>=0&&t<=1&&(o.a=!0);s>=0&&s<=1&&(o.b=!0);return o}(e,i)),c.a&&c.b?l:{x:1/0,y:1/0}}function y(t,s){const o=t[0],n=t[1];return o*s[0]+n*s[1]}function x(t,s){const o=t[0],n=t[1],e=s[0];return(n-s[1])/(o-e)}function _(t,s){const o={x:t[0]-d.x,y:t[1]-d.y},n={x:s[0]-d.x,y:s[1]-d.y},e=Math.sqrt(Math.pow(o.x,2)+Math.pow(o.y,2)),i=Math.sqrt(Math.pow(n.x,2)+Math.pow(n.y,2));let r=180*Math.acos((n.x*o.x+n.y*o.y)/(e*i))/Math.PI;const h=o.x*n.y-n.x*o.y;return r=isNaN(r)?0:r,r=h>0?360-r:r,r}function p(t,s){const o=t[0],n=t[1],e=s[0],i=s[1];return Math.abs(o-e)+Math.abs(n-i)}function b(t,s){const o=t[0],n=t[1],e=s[0],i=s[1];return Math.sqrt(Math.pow(o-e,2)+Math.pow(n-i,2))}function M(t,s,o,n,e,i){let r;"dist"===e?r=p:"distrel"===e?r=p:"euclid"===e?r=b:"polar"===e?(r=_,d={x:i[0],y:i[1]}):"dot"===e?r=y:Array.isArray(o[0])?r=y:(t=t[0],r=(t,s)=>t-s),function(t,s,o,n,e,i){let r=(h=n-1,Math.floor((h-1)/2));var h;for(;r>=0;)w(t,s,o,r,n-1,e,i),r--}(t,o,s,n,r,e);let h=n-1;for(;h>0;)A(s,h,0),h--,w(t,o,s,0,h,r,e)}function w(t,s,o,n,e,i,r){let h=n;const l=t=>2*t+1;for(;l(h)<=e;){const n=l(h);let c=h;const a=n=>{const e=i([s[o[n]],s[o[n]+1]],t);return"distrel"===r&&(t=[s[o[n]],s[o[n]+1]]),e};if(a(c)<a(n)&&(c=n),n+1<=e&&a(c)<a(n+1)&&(c=n+1),c===h)return;A(o,h,c),h=c}}function A(t,s,o){const n=t[s];t[s]=t[o],t[o]=n}function k(t,s){let o=0,n=-1/0,e=-1/0;if(s)for(const[i,r]of s.entries())t[r]>e?(e=t[r],n=t[r+1],o=i):t[r+1]>=n&&t[r]>=e&&(e=t[r],n=t[r+1],o=i);else for(let s=0;s>t.length;s++)t[s]>e&&(e=t[s],o=s);return{x:e,y:n,i:o}}function m(t,s){let o=0,n=1/0,e=1/0;if(s)for(const[i,r]of s.entries())t[r+1]<n?(e=t[r],n=t[r+1],o=i):t[r+1]<=n&&t[r]<=e&&(e=t[r],n=t[r+1],o=i);else for(let s=0;s<t.length;s++)t[s]<e&&(e=t[s],o=s);return{x:e,y:n,i:o}}function S(t,s,o,n,e){return M(n,s,t,s.length,o,e),s}var v=0;class L extends class{constructor(t,s=3){this.k=s,this.coords=t.slice(),this.index=[...this.coords.keys()].filter(t=>t%2==0),this.index=this.clean(this.index),this.center=this.calcCenter(),this.minY=m(this.coords,this.index),this.minX=function(t,s){let o=0,n=1/0,e=1/0;if(s)for(const[i,r]of s.entries())t[r]<e?(e=t[r],n=t[r+1],o=i):t[r+1]<=n&&t[r]<=e&&(e=t[r],n=t[r+1],o=i);else for(let s=0;s<t.length;s++)t[s]<e&&(e=t[s],o=s);return{x:e,y:n,i:o}}(this.coords,this.index),this.maxX=k(this.coords,this.index),this.cPoints=[],this.ray=null,this.hull=this.findConcaveHull(s)}findConcaveHull(t){const s=this.sortHeapAndClean(this.coords,this.index,"polar",[this.minX.x,this.minY.y],[this.center.x,this.center.y]);return this.concave(s,t)}concave(t,s){const o=t.slice();if(t.length<3)return console.log("len less than 3"),null;if(s>t.length-1)return console.log(v),console.log("k is too big"),null;if(3===t.length)return console.log("len 3"),t;let n=Math.min(Math.max(s,3),t.length-1);const e=m(this.coords,t).i,i={i:e,coord:t[e]};let r=i.coord;const h=[i.coord];let l=1;for(t.splice(i.i,1);(r!==i.coord||1===l)&&t.length>0;){v++,4===l&&t.push(i.coord);const s=this.nearestPoints(t,r,n),e=this.sortByAngle(s,r,h[h.length-2]);let c=!0,a=-1;for(;c&&a<e.length-1;){let t=0;e[a]===i.coord&&(t=1);let s=1;for(c=!1;!c&&s<h.length-t;){const t={x0:this.coords[h[l-1]],y0:this.coords[h[l-1]+1],x1:this.coords[e[a+1]],y1:this.coords[e[a+1]+1]},o={x0:this.coords[h[l-s]],y0:this.coords[h[l-s]+1],x1:this.coords[h[l-1-s]],y1:this.coords[h[l-1-s]+1]},n=g(o,t,!0),r=o.x0===t.x0&&o.y0===t.y0,u=e[a+1]===i.coord&&o.x1===t.x1&&o.y1===t.y1;!isFinite(n.x)||r||u||(c=!0),s++}a++}if(this.cPoints=e.slice(),c)return this.concave(o,++n);if(r=e[a],h.push(r),v>1/0)return h;t.splice(t.indexOf(r),1),l++}let c=!0;for(const s of t)c=this.pointInOrOut([this.coords[s],this.coords[s+1]],h,this.maxX.x+10);return c?(this.k=n,h):this.concave(o,++n)}sortByAngle(t,s,o){o=o&&o!==s?[this.coords[o],this.coords[o+1]]:[this.maxX.x+10,this.coords[s+1]],this.ray={x0:o[0],y0:o[1],x1:this.coords[s],y1:this.coords[s+1]};const n=[this.coords[s],this.coords[s+1]],e=S(this.coords,t,"polar",o,n).slice();let i,r;for(let t=0;t<e.length;t++){let s=[this.coords[e[t-1]],this.coords[e[t-1]+1]];0===t&&(s=n);const o=[this.coords[e[t]],this.coords[e[t]+1]],h=x(s,o),l=b(n,o);!isNaN(i)&&!isNaN(r)&&(Math.abs(h)===Math.abs(i)||h===1/0&&i===-1/0)&&l<r?(A(e,t,t-1),r=b(n,[this.coords[e[t]],this.coords[e[t]+1]])):r=l,i=x(s,o)}return e}nearestPoints(t,s,o){const n=[this.coords[s],this.coords[s+1]];t=S(this.coords.slice(),t.slice(),"euclid",n);const e=[];let i,r;o=Math.min(o,t.length-1);let h=0,l=0;for(;l<o;){const s=x(n,[this.coords[t[h]],this.coords[t[h]+1]]),o=b(n,[this.coords[t[h]],this.coords[t[h]+1]]);if(o===r?e.push(t[h]):0!==l&&s===i||(e.push(t[h]),l++),h++,h>t.length-1)return e;i=s,r=o}return e}sortHeapAndClean(t,s,o,n,e){return s=S(t.slice(),s.slice(),o,n,e),s=this.clean(s)}clean(t){t.length;let s=0;const o=[];for(const n of t){for(let e=0;e<t.length;e++)if(this.coords[t[e]]===this.coords[n]&&this.coords[t[e]+1]===this.coords[n+1]&&s!==e){let s=!0;for(const n of o)this.coords[t[e]]===this.coords[n[0]]&&this.coords[t[e]+1]===this.coords[n[0]+1]&&(s=!1,n[1]++);s&&o.push([n,0]);break}s++}const n=[];for(let s=0;s<t.length;s++){let e=!0;for(const n of o)this.coords[t[s]]===this.coords[n[0]]&&this.coords[t[s]+1]===this.coords[n[0]+1]&&n[1]>0&&(n[1]--,e=!1);e&&n.push(t[s])}return n}calcCenter(){const t={x:0,y:0};for(let s=0;s<this.coords.length;s+=2)t.x+=this.coords[s],t.y+=this.coords[s+1];return t.x/=this.coords.length/2,t.y/=this.coords.length/2,t}pointInOrOut(t,s,o){console.log("wee");const n={x0:t[0],y0:t[1],x1:o,y1:t[1]};this.ray=n;let e=0,i={x:1/0,y:1/0};for(let t=0;t<s.length;t++){const o={x0:this.coords[s[t]],y0:this.coords[s[t]+1],x1:this.coords[s[t+1>s.length-1?0:t+1]],y1:this.coords[s[t+1>s.length-1?0:t+1]+1]},r=g(n,o,!0);if(isFinite(r.x)){const h=!1;76===n.x0&&36===n.y0&&(this.cPoints.push(s[t]),console.log(h,r,n,o,e)),o.y1-o.y0>0&&!h?e++:o.y1-o.y0<0&&!h&&e--,i={x:Math.round(1e6*r.x),y:Math.round(1e6*r.y)}}}return 76===n.x0&&36===n.y0&&console.log(e,n),0!==Math.abs(e)}printPoints(t){const s=[];for(const o of t)s.push(this.coords[o],this.coords[o+1]);console.log(s)}get hullCoords(){return this.subset(this.hull)}subset(t){const s=[];for(const o of t)s.push(this.coords[o],this.coords[o+1]);return s}get coords2D(){const t=[],s=this.sortedCoords;for(;s.length;)t.push(s.splice(0,2));return t}get sortedCoords(){const t=[];for(const s of this.hull)t.push(this.coords[s],this.coords[s+1]);return t}}{constructor(t,s=3){super(t,s),this.origCoordsLen=t.length,this.intersectingLineSegs=[]}addPoints(t,s,o){this.k=3;const n=function(t){const s=[];for(let o=0;o<t.triangles.length;o++)o>t.halfedges[o]&&s.push(2*t.triangles[o],2*t.triangles[f(o)]);return s}(s);for(let s=0;s<this.hull.length-1;s++){const e=this.subset([this.hull[s],this.hull[s+1]]),i={x0:e[0],y0:e[1],x1:e[2],y1:e[3]},r=this.getIntersectingLines(i,n,t,o).reverse(),h=S(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat(),[...Array(r.length).keys()].map(t=>2*t),"euclid",[i.x0,i.y0]);this.intersectingLineSegs.push(this.hull[s]);const l=this.coords.length;this.coords=this.coords.concat(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat()),this.intersectingLineSegs=this.intersectingLineSegs.concat(h.map(t=>t+l))}this.intersectingLineSegs.push(this.intersectingLineSegs[0]),this.hull=this.intersectingLineSegs,this.clean(this.hull)}getIntersectingLines(t,s,o,n,e=null){const i=[];for(let l=0;l<s.length;l+=2){const c={x:o[s[l]],y:o[s[l]+1]};if((r=t,h=c,Math.abs((r.y1-r.y0)*h.x-(r.x1-r.x0)*h.y+r.x1*r.y0-r.y1*r.x0)/Math.sqrt(Math.pow(r.y1-r.y0,2)+Math.pow(r.x1-r.x0,2)))<=n){l+1>s.length-1&&(l=-1);const n=g(t,{x0:c.x,y0:c.y,x1:o[s[l+1]],y1:o[s[l+1]+1]},!1);isFinite(n.x)&&(e&&e([s[l],s[l+1],n]),i.push([s[l],s[l+1],n]))}}var r,h;return i}get k(){return super.k}set k(t){super.k=t}}return class{constructor(t,s,n,...e){if(t&&Array.isArray(t[0])&&2===t[0].length)t=t.flat();else if(t&&Array.isArray(t[0])&&2!==t[0].length)return;this._delaunator=new o(t),this._boundaries=[],this.boundedDelaunators=[];for(let o of e)o&&Array.isArray(o[0])&&2===o[0].length&&(o=o.flat()),this._boundaries.push(new L(o,s)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,n),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]));this._boundaries.push(new L(t,s)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,n),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]))}setTrianglesInsideBound(t){let s=[];const n=[...this.delaunator.coords.keys()].filter(t=>t%2==0),e=k(this.delaunator.coords,n);for(const o of n){const n={x:this.delaunator.coords[o],y:this.delaunator.coords[o+1]};t.pointInOrOut([n.x,n.y],t.hull,e.x+10)&&s.push(n.x,n.y)}s=s.concat(t.subset(t.hull));const i=new o(s),r=[];for(let s=0;s<i.triangles.length/3;s++){const o=3*s;let n=0,h=0;for(let t=0;t<3;t++)n+=i.coords[2*i.triangles[t+o]],h+=i.coords[2*i.triangles[t+o]+1];const l={x:n/3,y:h/3};t.pointInOrOut([l.x,l.y],t.hull,e.x+10)&&r.push(i.triangles[o],i.triangles[o+1],i.triangles[o+2])}return i.triangles=new i.triangles.constructor(r),i}update(t){const s=this.coords;for(const o of t.flat())s.push(o);this._delaunator=new o(s)}get coords2D(){const t=[],s=this.coords;for(let o=0;o<s.length;o+=2)t.push([s[o],s[o+1]]);return t}get coords(){return this.delaunator.coords}get triangles(){return this.delaunator.triangles}get hull(){return this.delaunator.hull}get delaunator(){return this._delaunator}get boundaries(){return this._boundaries}get holes(){return this.boundedDelaunators}}}));

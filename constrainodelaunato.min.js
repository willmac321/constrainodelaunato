!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):(t=t||self).ConstrainoDelaunato=s()}(this,(function(){"use strict";const t=Math.pow(2,-52),s=new Uint32Array(512);class i{static from(t,s=a,n=u){const e=t.length,o=new Float64Array(2*e);for(let i=0;i<e;i++){const e=t[i];o[2*i]=s(e),o[2*i+1]=n(e)}return new i(o)}constructor(t){const s=t.length>>1;if(s>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;const i=Math.max(2*s-5,0);this._triangles=new Uint32Array(3*i),this._halfedges=new Int32Array(3*i),this._hashSize=Math.ceil(Math.sqrt(s)),this._hullPrev=new Uint32Array(s),this._hullNext=new Uint32Array(s),this._hullTri=new Uint32Array(s),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(s),this._dists=new Float64Array(s),this.update()}update(){const{coords:s,_hullPrev:i,_hullNext:e,_hullTri:r,_hullHash:c}=this,a=s.length>>1;let u=1/0,d=1/0,f=-1/0,g=-1/0;for(let t=0;t<a;t++){const i=s[2*t],n=s[2*t+1];i<u&&(u=i),n<d&&(d=n),i>f&&(f=i),n>g&&(g=n),this._ids[t]=t}const y=(u+f)/2,x=(d+g)/2;let _,p,b,M=1/0;for(let t=0;t<a;t++){const i=n(y,x,s[2*t],s[2*t+1]);i<M&&(_=t,M=i)}const w=s[2*_],m=s[2*_+1];M=1/0;for(let t=0;t<a;t++){if(t===_)continue;const i=n(w,m,s[2*t],s[2*t+1]);i<M&&i>0&&(p=t,M=i)}let A=s[2*p],k=s[2*p+1],S=1/0;for(let t=0;t<a;t++){if(t===_||t===p)continue;const i=h(w,m,A,k,s[2*t],s[2*t+1]);i<S&&(b=t,S=i)}let v=s[2*b],I=s[2*b+1];if(S===1/0){for(let t=0;t<a;t++)this._dists[t]=s[2*t]-s[0]||s[2*t+1]-s[1];l(this._ids,this._dists,0,a-1);const t=new Uint32Array(a);let i=0;for(let s=0,n=-1/0;s<a;s++){const e=this._ids[s];this._dists[e]>n&&(t[i++]=e,n=this._dists[e])}return this.hull=t.subarray(0,i),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(o(w,m,A,k,v,I)){const t=p,s=A,i=k;p=b,A=v,k=I,b=t,v=s,I=i}const L=function(t,s,i,n,e,o){const r=i-t,h=n-s,l=e-t,c=o-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l);return{x:t+(c*a-h*u)*d,y:s+(r*u-l*a)*d}}(w,m,A,k,v,I);this._cx=L.x,this._cy=L.y;for(let t=0;t<a;t++)this._dists[t]=n(s[2*t],s[2*t+1],L.x,L.y);l(this._ids,this._dists,0,a-1),this._hullStart=_;let P=3;e[_]=i[b]=p,e[p]=i[_]=b,e[b]=i[p]=_,r[_]=0,r[p]=1,r[b]=2,c.fill(-1),c[this._hashKey(w,m)]=_,c[this._hashKey(A,k)]=p,c[this._hashKey(v,I)]=b,this.trianglesLen=0,this._addTriangle(_,p,b,-1,-1,-1);for(let n,h,l=0;l<this._ids.length;l++){const a=this._ids[l],u=s[2*a],d=s[2*a+1];if(l>0&&Math.abs(u-n)<=t&&Math.abs(d-h)<=t)continue;if(n=u,h=d,a===_||a===p||a===b)continue;let f=0;for(let t=0,s=this._hashKey(u,d);t<this._hashSize&&(f=c[(s+t)%this._hashSize],-1===f||f===e[f]);t++);f=i[f];let g,y=f;for(;g=e[y],!o(u,d,s[2*y],s[2*y+1],s[2*g],s[2*g+1]);)if(y=g,y===f){y=-1;break}if(-1===y)continue;let x=this._addTriangle(y,a,e[y],-1,-1,r[y]);r[a]=this._legalize(x+2),r[y]=x,P++;let M=e[y];for(;g=e[M],o(u,d,s[2*M],s[2*M+1],s[2*g],s[2*g+1]);)x=this._addTriangle(M,a,g,r[a],-1,r[M]),r[a]=this._legalize(x+2),e[M]=M,P--,M=g;if(y===f)for(;g=i[y],o(u,d,s[2*g],s[2*g+1],s[2*y],s[2*y+1]);)x=this._addTriangle(g,a,y,-1,r[y],r[g]),this._legalize(x+2),r[g]=x,e[y]=y,P--,y=g;this._hullStart=i[a]=y,e[y]=i[M]=a,e[a]=M,c[this._hashKey(u,d)]=a,c[this._hashKey(s[2*y],s[2*y+1])]=y}this.hull=new Uint32Array(P);for(let t=0,s=this._hullStart;t<P;t++)this.hull[t]=s,s=e[s];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,s){return Math.floor(function(t,s){const i=t/(Math.abs(t)+Math.abs(s));return(s>0?3-i:1+i)/4}(t-this._cx,s-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:i,_halfedges:n,coords:e}=this;let o=0,h=0;for(;;){const l=n[t],c=t-t%3;if(h=c+(t+2)%3,-1===l){if(0===o)break;t=s[--o];continue}const a=l-l%3,u=c+(t+1)%3,d=a+(l+2)%3,f=i[h],g=i[t],y=i[u],x=i[d];if(r(e[2*f],e[2*f+1],e[2*g],e[2*g+1],e[2*y],e[2*y+1],e[2*x],e[2*x+1])){i[t]=x,i[l]=f;const e=n[d];if(-1===e){let s=this._hullStart;do{if(this._hullTri[s]===d){this._hullTri[s]=t;break}s=this._hullPrev[s]}while(s!==this._hullStart)}this._link(t,e),this._link(l,n[h]),this._link(h,d);const r=a+(l+1)%3;o<s.length&&(s[o++]=r)}else{if(0===o)break;t=s[--o]}}return h}_link(t,s){this._halfedges[t]=s,-1!==s&&(this._halfedges[s]=t)}_addTriangle(t,s,i,n,e,o){const r=this.trianglesLen;return this._triangles[r]=t,this._triangles[r+1]=s,this._triangles[r+2]=i,this._link(r,n),this._link(r+1,e),this._link(r+2,o),this.trianglesLen+=3,r}}function n(t,s,i,n){const e=t-i,o=s-n;return e*e+o*o}function e(t,s,i,n,e,o){const r=(n-s)*(e-t),h=(i-t)*(o-s);return Math.abs(r-h)>=33306690738754716e-32*Math.abs(r+h)?r-h:0}function o(t,s,i,n,o,r){return(e(o,r,t,s,i,n)||e(t,s,i,n,o,r)||e(i,n,o,r,t,s))<0}function r(t,s,i,n,e,o,r,h){const l=t-r,c=s-h,a=i-r,u=n-h,d=e-r,f=o-h,g=a*a+u*u,y=d*d+f*f;return l*(u*y-g*f)-c*(a*y-g*d)+(l*l+c*c)*(a*f-u*d)<0}function h(t,s,i,n,e,o){const r=i-t,h=n-s,l=e-t,c=o-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l),f=(c*a-h*u)*d,g=(r*u-l*a)*d;return f*f+g*g}function l(t,s,i,n){if(n-i<=20)for(let e=i+1;e<=n;e++){const n=t[e],o=s[n];let r=e-1;for(;r>=i&&s[t[r]]>o;)t[r+1]=t[r--];t[r+1]=n}else{let e=i+1,o=n;c(t,i+n>>1,e),s[t[i]]>s[t[n]]&&c(t,i,n),s[t[e]]>s[t[n]]&&c(t,e,n),s[t[i]]>s[t[e]]&&c(t,i,e);const r=t[e],h=s[r];for(;;){do{e++}while(s[t[e]]<h);do{o--}while(s[t[o]]>h);if(o<e)break;c(t,e,o)}t[i+1]=t[o],t[o]=r,n-e+1>=o-i?(l(t,s,e,n),l(t,s,i,o-1)):(l(t,s,i,o-1),l(t,s,e,n))}}function c(t,s,i){const n=t[s];t[s]=t[i],t[i]=n}function a(t){return t[0]}function u(t){return t[1]}var d;function f(t){return t%3==2?t-2:t+1}function g(t,s,i=!1){const n=(s.y1-s.y0)*(t.x1-t.x0)-(s.x1-s.x0)*(t.y1-t.y0);if(0===n)return{x:1/0,y:1/0};let e=t.y0-s.y0,o=t.x0-s.x0;const r=(s.x1-s.x0)*e-(s.y1-s.y0)*o,h=(t.x1-t.x0)*e-(t.y1-t.y0)*o;e=r/n,o=h/n;const l={x:t.x0+e*(t.x1-t.x0),y:t.y0+e*(t.y1-t.y0)};let c=function(t,s){const i={a:!1,b:!1};t>0&&t<1&&(i.a=!0);s>0&&s<1&&(i.b=!0);return i}(e,o);return i&&(c=function(t,s){const i={a:!1,b:!1};t>=0&&t<=1&&(i.a=!0);s>=0&&s<=1&&(i.b=!0);return i}(e,o)),c.a&&c.b?l:{x:1/0,y:1/0}}function y(t,s){const i=t[0],n=t[1];return i*s[0]+n*s[1]}function x(t,s){const i=t[0],n=t[1],e=s[0];return(n-s[1])/(i-e)}function _(t,s){const i={x:t[0]-d.x,y:t[1]-d.y},n={x:s[0]-d.x,y:s[1]-d.y},e=Math.sqrt(Math.pow(i.x,2)+Math.pow(i.y,2)),o=Math.sqrt(Math.pow(n.x,2)+Math.pow(n.y,2));let r=180*Math.acos((n.x*i.x+n.y*i.y)/(e*o))/Math.PI;const h=i.x*n.y-n.x*i.y;return r=isNaN(r)?0:r,r=h>0?360-r:r,r}function p(t,s){const i=t[0],n=t[1],e=s[0],o=s[1];return Math.abs(i-e)+Math.abs(n-o)}function b(t,s){const i=t[0],n=t[1],e=s[0],o=s[1];return Math.sqrt(Math.pow(i-e,2)+Math.pow(n-o,2))}function M(t,s,i,n,e,o){let r;"dist"===e?r=p:"distrel"===e?r=p:"euclid"===e?r=b:"polar"===e?(r=_,d={x:o[0],y:o[1]}):"dot"===e?r=y:Array.isArray(i[0])?r=y:(t=t[0],r=(t,s)=>t-s),function(t,s,i,n,e,o){let r=(h=n-1,Math.floor((h-1)/2));var h;for(;r>=0;)w(t,s,i,r,n-1,e,o),r--}(t,i,s,n,r,e);let h=n-1;for(;h>0;)m(s,h,0),h--,w(t,i,s,0,h,r,e)}function w(t,s,i,n,e,o,r){let h=n;const l=t=>2*t+1;for(;l(h)<=e;){const n=l(h);let c=h;const a=n=>{const e=o([s[i[n]],s[i[n]+1]],t);return"distrel"===r&&(t=[s[i[n]],s[i[n]+1]]),e};if(a(c)<a(n)&&(c=n),n+1<=e&&a(c)<a(n+1)&&(c=n+1),c===h)return;m(i,h,c),h=c}}function m(t,s,i){const n=t[s];t[s]=t[i],t[i]=n}function A(t,s){let i=0,n=-1/0,e=-1/0;if(s)for(const[o,r]of s.entries())t[r]>e?(e=t[r],n=t[r+1],i=o):t[r+1]>=n&&t[r]>=e&&(e=t[r],n=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]>e&&(e=t[s],i=s);return{x:e,y:n,i:i}}function k(t,s){let i=0,n=1/0,e=1/0;if(s)for(const[o,r]of s.entries())t[r+1]<n?(e=t[r],n=t[r+1],i=o):t[r+1]<=n&&t[r]<=e&&(e=t[r],n=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]<e&&(e=t[s],i=s);return{x:e,y:n,i:i}}function S(t,s,i,n,e){return M(n,s,t,s.length,i,e),s}var v=0;class I extends class{constructor(t,s=3){this.k=s,this.coords=t.slice(),this.index=[...this.coords.keys()].filter(t=>t%2==0),this.index=this.clean(this.index),this.center=this.calcCenter(),this.minY=k(this.coords,this.index),this.maxY=function(t,s){let i=0,n=-1/0,e=-1/0;if(s)for(const[o,r]of s.entries())t[r+1]>n?(e=t[r],n=t[r+1],i=o):t[r+1]>=n&&t[r]>=e&&(e=t[r],n=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]>e&&(e=t[s],i=s);return{x:e,y:n,i:i}}(this.coords,this.index),this.minX=function(t,s){let i=0,n=1/0,e=1/0;if(s)for(const[o,r]of s.entries())t[r]<e?(e=t[r],n=t[r+1],i=o):t[r+1]<=n&&t[r]<=e&&(e=t[r],n=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]<e&&(e=t[s],i=s);return{x:e,y:n,i:i}}(this.coords,this.index),this.maxX=A(this.coords,this.index),this.maxD=Math.sqrt(Math.pow(this.maxX.x-this.minX.x,2)+Math.pow(this.maxY.y-this.minY.y,2)),this.maxR=this.maxR/2,this.offsetAngle=1,this.cPoints=[],this.ray=null,this.hull=this.findConcaveHull(s)}findConcaveHull(t){const s=this.sortHeapAndClean(this.coords,this.index,"polar",[this.minX.x,this.minY.y],[this.center.x,this.center.y]);return this.concave(s,t)}concave(t,s){const i=t.slice();if(t.length<3)return console.log("len less than 3"),null;if(s>t.length-1)return console.log(v),console.log("k is too big"),null;if(3===t.length)return console.log("len 3"),t;let n=Math.min(Math.max(s,3),t.length-1);const e=k(this.coords,t).i,o={i:e,coord:t[e]};let r=o.coord;const h=[o.coord];let l=1;for(t.splice(o.i,1);(r!==o.coord||1===l)&&t.length>0;){v++,4===l&&t.push(o.coord);const s=this.nearestPoints(t,r,n),e=this.sortByAngle(s,r,h[h.length-2]);let c=!0,a=-1;for(;c&&a<e.length-1;){let t=0;e[a]===o.coord&&(t=1);let s=1;for(c=!1;!c&&s<h.length-t;){const t={x0:this.coords[h[l-1]],y0:this.coords[h[l-1]+1],x1:this.coords[e[a+1]],y1:this.coords[e[a+1]+1]},i={x0:this.coords[h[l-s]],y0:this.coords[h[l-s]+1],x1:this.coords[h[l-1-s]],y1:this.coords[h[l-1-s]+1]},n=g(i,t,!0),r=i.x0===t.x0&&i.y0===t.y0,u=e[a+1]===o.coord&&i.x1===t.x1&&i.y1===t.y1;!isFinite(n.x)||r||u||(c=!0),s++}a++}if(this.cPoints=e.slice(),c)return this.concave(i,++n);if(r=e[a],h.push(r),v>1/0)return h;t.splice(t.indexOf(r),1),l++}let c=!0;for(const s of t)if(c=this.pointInOrOut([this.coords[s],this.coords[s+1]],h,0),!c)break;return c?(this.k=n,h):this.concave(i,++n)}sortByAngle(t,s,i){i=i&&i!==s?[this.coords[i],this.coords[i+1]]:[this.maxX.x+10,this.coords[s+1]],this.ray={x0:i[0],y0:i[1],x1:this.coords[s],y1:this.coords[s+1]};const n=[this.coords[s],this.coords[s+1]],e=S(this.coords,t,"polar",i,n).slice();let o,r;for(let t=0;t<e.length;t++){let s=[this.coords[e[t-1]],this.coords[e[t-1]+1]];0===t&&(s=n);const i=[this.coords[e[t]],this.coords[e[t]+1]],h=x(s,i),l=b(n,i);!isNaN(o)&&!isNaN(r)&&(Math.abs(h)===Math.abs(o)||h===1/0&&o===-1/0)&&l<r?(m(e,t,t-1),r=b(n,[this.coords[e[t]],this.coords[e[t]+1]])):r=l,o=x(s,i)}return e}nearestPoints(t,s,i){const n=[this.coords[s],this.coords[s+1]];t=S(this.coords.slice(),t.slice(),"euclid",n);const e=[];let o,r;i=Math.min(i,t.length-1);let h=0,l=0;for(;l<i;){const s=x(n,[this.coords[t[h]],this.coords[t[h]+1]]),i=b(n,[this.coords[t[h]],this.coords[t[h]+1]]);if(i===r?e.push(t[h]):0!==l&&s===o||(e.push(t[h]),l++),h++,h>t.length-1)return e;o=s,r=i}return e}sortHeapAndClean(t,s,i,n,e){return s=S(t.slice(),s.slice(),i,n,e),s=this.clean(s)}clean(t){t.length;let s=0;const i=[];for(const n of t){for(let e=0;e<t.length;e++)if(this.coords[t[e]]===this.coords[n]&&this.coords[t[e]+1]===this.coords[n+1]&&s!==e){let s=!0;for(const n of i)this.coords[t[e]]===this.coords[n[0]]&&this.coords[t[e]+1]===this.coords[n[0]+1]&&(s=!1,n[1]++);s&&i.push([n,0]);break}s++}const n=[];for(let s=0;s<t.length;s++){let e=!0;for(const n of i)this.coords[t[s]]===this.coords[n[0]]&&this.coords[t[s]+1]===this.coords[n[0]+1]&&n[1]>0&&(n[1]--,e=!1);e&&n.push(t[s])}return n}calcCenter(){const t={x:0,y:0};for(let s=0;s<this.coords.length;s+=2)t.x+=this.coords[s],t.y+=this.coords[s+1];return t.x/=this.coords.length/2,t.y/=this.coords.length/2,t}pointInOrOut(t,s,i){const n=t[0]+this.maxD*Math.cos(i*Math.PI/180),e=t[1]+this.maxD*Math.sin(i*Math.PI/180),o={x0:t[0],y0:t[1],x1:n,y1:e};this.ray=o;let r=0,h={x:1/0,y:1/0};for(let n=0;n<s.length;n++){const e={x0:this.coords[s[n]],y0:this.coords[s[n]+1],x1:this.coords[s[n+1>s.length-1?0:n+1]],y1:this.coords[s[n+1>s.length-1?0:n+1]+1]},l=g(o,e,!0);if(isFinite(l.x)){const n=Math.round(1e6*l.x)===h.x&&Math.round(1e6*l.y)===h.y;if(e.y1-e.y0>0&&!n)r++;else if(e.y1-e.y0<0&&!n)r--;else if(n&&i<360)return this.pointInOrOut(t,s,++i);h={x:Math.round(1e6*l.x),y:Math.round(1e6*l.y)}}}return 0!==Math.abs(r)}printPoints(t){const s=[];for(const i of t)s.push(this.coords[i],this.coords[i+1]);console.log(s)}get hullCoords(){return this.subset(this.hull)}subset(t){const s=[];for(const i of t)s.push(this.coords[i],this.coords[i+1]);return s}get coords2D(){const t=[],s=this.sortedCoords;for(;s.length;)t.push(s.splice(0,2));return t}get sortedCoords(){const t=[];for(const s of this.hull)t.push(this.coords[s],this.coords[s+1]);return t}}{constructor(t,s=3){super(t,s),this.origCoordsLen=t.length,this.intersectingLineSegs=[]}addPoints(t,s,i){this.k=3;const n=function(t){const s=[];for(let i=0;i<t.triangles.length;i++)i>t.halfedges[i]&&s.push(2*t.triangles[i],2*t.triangles[f(i)]);return s}(s);for(let s=0;s<this.hull.length-1;s++){const e=this.subset([this.hull[s],this.hull[s+1]]),o={x0:e[0],y0:e[1],x1:e[2],y1:e[3]},r=this.getIntersectingLines(o,n,t,i).reverse(),h=S(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat(),[...Array(r.length).keys()].map(t=>2*t),"euclid",[o.x0,o.y0]);this.intersectingLineSegs.push(this.hull[s]);const l=this.coords.length;this.coords=this.coords.concat(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat()),this.intersectingLineSegs=this.intersectingLineSegs.concat(h.map(t=>t+l))}this.intersectingLineSegs.push(this.intersectingLineSegs[0]),this.hull=this.intersectingLineSegs,this.clean(this.hull)}getIntersectingLines(t,s,i,n,e=null){const o=[];for(let l=0;l<s.length;l+=2){const c={x:i[s[l]],y:i[s[l]+1]};if((r=t,h=c,Math.abs((r.y1-r.y0)*h.x-(r.x1-r.x0)*h.y+r.x1*r.y0-r.y1*r.x0)/Math.sqrt(Math.pow(r.y1-r.y0,2)+Math.pow(r.x1-r.x0,2)))<=n){l+1>s.length-1&&(l=-1);const n=g(t,{x0:c.x,y0:c.y,x1:i[s[l+1]],y1:i[s[l+1]+1]},!1);isFinite(n.x)&&(e&&e([s[l],s[l+1],n]),o.push([s[l],s[l+1],n]))}}var r,h;return o}get k(){return super.k}set k(t){super.k=t}}return class{constructor(t,s,n,...e){if(t&&Array.isArray(t[0])&&2===t[0].length)t=t.flat();else if(t&&Array.isArray(t[0])&&2!==t[0].length)return;this._delaunator=new i(t),this._boundaries=[],this.boundedDelaunators=[];for(let i of e)i&&Array.isArray(i[0])&&2===i[0].length&&(i=i.flat()),this._boundaries.push(new I(i,s)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,n),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]));this._boundaries.push(new I(t,s)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,n),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]))}setTrianglesInsideBound(t){let s=[];const n=[...this.delaunator.coords.keys()].filter(t=>t%2==0),e=A(this.delaunator.coords,n);for(const i of n){const n={x:this.delaunator.coords[i],y:this.delaunator.coords[i+1]};t.pointInOrOut([n.x,n.y],t.hull,e.x+10)&&s.push(n.x,n.y)}s=s.concat(t.subset(t.hull));const o=new i(s),r=[];for(let s=0;s<o.triangles.length/3;s++){const i=3*s;let n=0,h=0;for(let t=0;t<3;t++)n+=o.coords[2*o.triangles[t+i]],h+=o.coords[2*o.triangles[t+i]+1];const l={x:n/3,y:h/3};t.pointInOrOut([l.x,l.y],t.hull,e.x+10)&&r.push(o.triangles[i],o.triangles[i+1],o.triangles[i+2])}return o.triangles=new o.triangles.constructor(r),o}update(t){const s=this.coords;for(const i of t.flat())s.push(i);this._delaunator=new i(s)}get coords2D(){const t=[],s=this.coords;for(let i=0;i<s.length;i+=2)t.push([s[i],s[i+1]]);return t}get coords(){return this.delaunator.coords}get triangles(){return this.delaunator.triangles}get hull(){return this.delaunator.hull}get delaunator(){return this._delaunator}get boundaries(){return this._boundaries}get holes(){return this.boundedDelaunators}}}));

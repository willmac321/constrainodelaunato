!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):(t=t||self).ConstrainoDelaunato=s()}(this,(function(){"use strict";const t=Math.pow(2,-52),s=new Uint32Array(512);class e{static from(t,s=a,i=u){const n=t.length,o=new Float64Array(2*n);for(let e=0;e<n;e++){const n=t[e];o[2*e]=s(n),o[2*e+1]=i(n)}return new e(o)}constructor(t){const s=t.length>>1;if(s>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;const e=Math.max(2*s-5,0);this._triangles=new Uint32Array(3*e),this._halfedges=new Int32Array(3*e),this._hashSize=Math.ceil(Math.sqrt(s)),this._hullPrev=new Uint32Array(s),this._hullNext=new Uint32Array(s),this._hullTri=new Uint32Array(s),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(s),this._dists=new Float64Array(s),this.update()}update(){const{coords:s,_hullPrev:e,_hullNext:n,_hullTri:r,_hullHash:c}=this,a=s.length>>1;let u=1/0,d=1/0,f=-1/0,g=-1/0;for(let t=0;t<a;t++){const e=s[2*t],i=s[2*t+1];e<u&&(u=e),i<d&&(d=i),e>f&&(f=e),i>g&&(g=i),this._ids[t]=t}const y=(u+f)/2,x=(d+g)/2;let _,p,b,M=1/0;for(let t=0;t<a;t++){const e=i(y,x,s[2*t],s[2*t+1]);e<M&&(_=t,M=e)}const w=s[2*_],m=s[2*_+1];M=1/0;for(let t=0;t<a;t++){if(t===_)continue;const e=i(w,m,s[2*t],s[2*t+1]);e<M&&e>0&&(p=t,M=e)}let A=s[2*p],k=s[2*p+1],S=1/0;for(let t=0;t<a;t++){if(t===_||t===p)continue;const e=h(w,m,A,k,s[2*t],s[2*t+1]);e<S&&(b=t,S=e)}let v=s[2*b],L=s[2*b+1];if(S===1/0){for(let t=0;t<a;t++)this._dists[t]=s[2*t]-s[0]||s[2*t+1]-s[1];l(this._ids,this._dists,0,a-1);const t=new Uint32Array(a);let e=0;for(let s=0,i=-1/0;s<a;s++){const n=this._ids[s];this._dists[n]>i&&(t[e++]=n,i=this._dists[n])}return this.hull=t.subarray(0,e),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(o(w,m,A,k,v,L)){const t=p,s=A,e=k;p=b,A=v,k=L,b=t,v=s,L=e}const I=function(t,s,e,i,n,o){const r=e-t,h=i-s,l=n-t,c=o-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l);return{x:t+(c*a-h*u)*d,y:s+(r*u-l*a)*d}}(w,m,A,k,v,L);this._cx=I.x,this._cy=I.y;for(let t=0;t<a;t++)this._dists[t]=i(s[2*t],s[2*t+1],I.x,I.y);l(this._ids,this._dists,0,a-1),this._hullStart=_;let P=3;n[_]=e[b]=p,n[p]=e[_]=b,n[b]=e[p]=_,r[_]=0,r[p]=1,r[b]=2,c.fill(-1),c[this._hashKey(w,m)]=_,c[this._hashKey(A,k)]=p,c[this._hashKey(v,L)]=b,this.trianglesLen=0,this._addTriangle(_,p,b,-1,-1,-1);for(let i,h,l=0;l<this._ids.length;l++){const a=this._ids[l],u=s[2*a],d=s[2*a+1];if(l>0&&Math.abs(u-i)<=t&&Math.abs(d-h)<=t)continue;if(i=u,h=d,a===_||a===p||a===b)continue;let f=0;for(let t=0,s=this._hashKey(u,d);t<this._hashSize&&(f=c[(s+t)%this._hashSize],-1===f||f===n[f]);t++);f=e[f];let g,y=f;for(;g=n[y],!o(u,d,s[2*y],s[2*y+1],s[2*g],s[2*g+1]);)if(y=g,y===f){y=-1;break}if(-1===y)continue;let x=this._addTriangle(y,a,n[y],-1,-1,r[y]);r[a]=this._legalize(x+2),r[y]=x,P++;let M=n[y];for(;g=n[M],o(u,d,s[2*M],s[2*M+1],s[2*g],s[2*g+1]);)x=this._addTriangle(M,a,g,r[a],-1,r[M]),r[a]=this._legalize(x+2),n[M]=M,P--,M=g;if(y===f)for(;g=e[y],o(u,d,s[2*g],s[2*g+1],s[2*y],s[2*y+1]);)x=this._addTriangle(g,a,y,-1,r[y],r[g]),this._legalize(x+2),r[g]=x,n[y]=y,P--,y=g;this._hullStart=e[a]=y,n[y]=e[M]=a,n[a]=M,c[this._hashKey(u,d)]=a,c[this._hashKey(s[2*y],s[2*y+1])]=y}this.hull=new Uint32Array(P);for(let t=0,s=this._hullStart;t<P;t++)this.hull[t]=s,s=n[s];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,s){return Math.floor(function(t,s){const e=t/(Math.abs(t)+Math.abs(s));return(s>0?3-e:1+e)/4}(t-this._cx,s-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:e,_halfedges:i,coords:n}=this;let o=0,h=0;for(;;){const l=i[t],c=t-t%3;if(h=c+(t+2)%3,-1===l){if(0===o)break;t=s[--o];continue}const a=l-l%3,u=c+(t+1)%3,d=a+(l+2)%3,f=e[h],g=e[t],y=e[u],x=e[d];if(r(n[2*f],n[2*f+1],n[2*g],n[2*g+1],n[2*y],n[2*y+1],n[2*x],n[2*x+1])){e[t]=x,e[l]=f;const n=i[d];if(-1===n){let s=this._hullStart;do{if(this._hullTri[s]===d){this._hullTri[s]=t;break}s=this._hullPrev[s]}while(s!==this._hullStart)}this._link(t,n),this._link(l,i[h]),this._link(h,d);const r=a+(l+1)%3;o<s.length&&(s[o++]=r)}else{if(0===o)break;t=s[--o]}}return h}_link(t,s){this._halfedges[t]=s,-1!==s&&(this._halfedges[s]=t)}_addTriangle(t,s,e,i,n,o){const r=this.trianglesLen;return this._triangles[r]=t,this._triangles[r+1]=s,this._triangles[r+2]=e,this._link(r,i),this._link(r+1,n),this._link(r+2,o),this.trianglesLen+=3,r}}function i(t,s,e,i){const n=t-e,o=s-i;return n*n+o*o}function n(t,s,e,i,n,o){const r=(i-s)*(n-t),h=(e-t)*(o-s);return Math.abs(r-h)>=33306690738754716e-32*Math.abs(r+h)?r-h:0}function o(t,s,e,i,o,r){return(n(o,r,t,s,e,i)||n(t,s,e,i,o,r)||n(e,i,o,r,t,s))<0}function r(t,s,e,i,n,o,r,h){const l=t-r,c=s-h,a=e-r,u=i-h,d=n-r,f=o-h,g=a*a+u*u,y=d*d+f*f;return l*(u*y-g*f)-c*(a*y-g*d)+(l*l+c*c)*(a*f-u*d)<0}function h(t,s,e,i,n,o){const r=e-t,h=i-s,l=n-t,c=o-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l),f=(c*a-h*u)*d,g=(r*u-l*a)*d;return f*f+g*g}function l(t,s,e,i){if(i-e<=20)for(let n=e+1;n<=i;n++){const i=t[n],o=s[i];let r=n-1;for(;r>=e&&s[t[r]]>o;)t[r+1]=t[r--];t[r+1]=i}else{let n=e+1,o=i;c(t,e+i>>1,n),s[t[e]]>s[t[i]]&&c(t,e,i),s[t[n]]>s[t[i]]&&c(t,n,i),s[t[e]]>s[t[n]]&&c(t,e,n);const r=t[n],h=s[r];for(;;){do{n++}while(s[t[n]]<h);do{o--}while(s[t[o]]>h);if(o<n)break;c(t,n,o)}t[e+1]=t[o],t[o]=r,i-n+1>=o-e?(l(t,s,n,i),l(t,s,e,o-1)):(l(t,s,e,o-1),l(t,s,n,i))}}function c(t,s,e){const i=t[s];t[s]=t[e],t[e]=i}function a(t){return t[0]}function u(t){return t[1]}var d;function f(t){return t%3==2?t-2:t+1}function g(t){const s=[];for(let e=0;e<t.triangles.length;e++)e>t.halfedges[e]&&s.push(2*t.triangles[e],2*t.triangles[f(e)]);return s}function y(t,s,e=!1){const i=(s.y1-s.y0)*(t.x1-t.x0)-(s.x1-s.x0)*(t.y1-t.y0);if(0===i)return{x:1/0,y:1/0};let n=t.y0-s.y0,o=t.x0-s.x0;const r=(s.x1-s.x0)*n-(s.y1-s.y0)*o,h=(t.x1-t.x0)*n-(t.y1-t.y0)*o;n=r/i,o=h/i;const l={x:t.x0+n*(t.x1-t.x0),y:t.y0+n*(t.y1-t.y0)};let c=function(t,s){const e={a:!1,b:!1};t>0&&t<1&&(e.a=!0);s>0&&s<1&&(e.b=!0);return e}(n,o);return e&&(c=function(t,s){const e={a:!1,b:!1};t>=0&&t<=1&&(e.a=!0);s>=0&&s<=1&&(e.b=!0);return e}(n,o)),c.a&&c.b?l:{x:1/0,y:1/0}}function x(t,s){const e=t[0],i=t[1];return e*s[0]+i*s[1]}function _(t,s){const e=t[0],i=t[1],n=s[0];return(i-s[1])/(e-n)}function p(t,s){const e={x:t[0]-d.x,y:t[1]-d.y},i={x:s[0]-d.x,y:s[1]-d.y},n=Math.sqrt(Math.pow(e.x,2)+Math.pow(e.y,2)),o=Math.sqrt(Math.pow(i.x,2)+Math.pow(i.y,2));let r=180*Math.acos((i.x*e.x+i.y*e.y)/(n*o))/Math.PI;const h=e.x*i.y-i.x*e.y;return r=isNaN(r)?0:r,r=h>0?360-r:r,r}function b(t,s){const e=t[0],i=t[1],n=s[0],o=s[1];return Math.abs(e-n)+Math.abs(i-o)}function M(t,s){const e=t[0],i=t[1],n=s[0],o=s[1];return Math.sqrt(Math.pow(e-n,2)+Math.pow(i-o,2))}function w(t,s,e,i,n,o){let r;"dist"===n||"distrel"===n?r=b:"euclid"===n?r=M:"polar"===n?(r=p,d={x:o[0],y:o[1]}):"dot"===n||Array.isArray(e[0])?r=x:(t=t[0],r=(t,s)=>t-s),function(t,s,e,i,n,o){let r=(h=i-1,Math.floor((h-1)/2));var h;for(;r>=0;)m(t,s,e,r,i-1,n,o),r--}(t,e,s,i,r,n);let h=i-1;for(;h>0;)A(s,h,0),h--,m(t,e,s,0,h,r,n)}function m(t,s,e,i,n,o,r){let h=i;const l=t=>2*t+1;for(;l(h)<=n;){const i=l(h);let c=h;const a=i=>{const n=o([s[e[i]],s[e[i]+1]],t);return"distrel"===r&&(t=[s[e[i]],s[e[i]+1]]),n};if(a(c)<a(i)&&(c=i),i+1<=n&&a(c)<a(i+1)&&(c=i+1),c===h)return;A(e,h,c),h=c}}function A(t,s,e){const i=t[s];t[s]=t[e],t[e]=i}function k(t,s){let e=0,i=-1/0,n=-1/0;if(s)for(const[o,r]of s.entries())(t[r]>n||t[r+1]>=i&&t[r]>=n)&&(n=t[r],i=t[r+1],e=o);else for(let s=0;s<t.length;s++)t[s]>n&&(n=t[s],e=s);return{x:n,y:i,i:e}}function S(t,s){let e=0,i=1/0,n=1/0;if(s)for(const[o,r]of s.entries())(t[r+1]<i||t[r+1]<=i&&t[r]<=n)&&(n=t[r],i=t[r+1],e=o);else for(let s=0;s<t.length;s++)t[s]<n&&(n=t[s],e=s);return{x:n,y:i,i:e}}function v(t,s,e,i,n){return w(i,s,t,s.length,e,n),s}var L=0;class I extends class{constructor(t,s=3,e){this.k=s,this.dist=e,this.coords=t.slice(),this.index=[...this.coords.keys()].filter(t=>t%2==0),this.index=this.clean(this.index),this.center=this.calcCenter(),this.minY=S(this.coords,this.index),this.maxY=function(t,s){let e=0,i=-1/0,n=-1/0;if(s)for(const[o,r]of s.entries())(t[r+1]>i||t[r+1]>=i&&t[r]>=n)&&(n=t[r],i=t[r+1],e=o);else for(let s=0;s<t.length;s++)t[s]>n&&(n=t[s],e=s);return{x:n,y:i,i:e}}(this.coords,this.index),this.minX=function(t,s){let e=0,i=1/0,n=1/0;if(s)for(const[o,r]of s.entries())(t[r]<n||t[r+1]<=i&&t[r]<=n)&&(n=t[r],i=t[r+1],e=o);else for(let s=0;s<t.length;s++)t[s]<n&&(n=t[s],e=s);return{x:n,y:i,i:e}}(this.coords,this.index),this.maxX=k(this.coords,this.index),this.maxD=Math.sqrt(Math.pow(this.maxX.x-this.minX.x,2)+Math.pow(this.maxY.y-this.minY.y,2)),this.offsetAngle=1,this.cPoints=[],this.ray=null,this.hull=this.findConcaveHull(s)}findConcaveHull(t){const s=this.sortHeapAndClean(this.coords,this.index,"polar",[this.minX.x,this.minY.y],[this.center.x,this.center.y]),e=[...s];let i=this.concave(s,t);return null===i&&(this.dist=1/0,i=this.concave(e,t)),i}concave(t,s){const e=t.slice();if(t.length<3)return console.error(`Remaining points can not form a polygon k:${s}`),null;if(s>t.length-1)return console.error(`K exceeds total length of points available k:${s}`),null;if(3===t.length)return t;let i=Math.min(Math.max(s,3),t.length-1);const n=S(this.coords,t).i,o={i:n,coord:t[n]};let r=o.coord;const h=[o.coord];let l=1;for(t.splice(o.i,1);(r!==o.coord||1===l)&&t.length>0;){L++,(4===l&&t.indexOf(o.coord)<0||l<=e.length-1&&l<4&&1===t.length&&t.indexOf(o.coord)<0)&&t.push(o.coord);const s=this.nearestPoints(t,r,i),n=this.sortByAngle(s,r,h[h.length-2]);let c=!0,a=-1;for(;c&&a<n.length-1;){let t=0;n[a]===o.coord&&(t=1);let s=1;for(c=!1;!c&&s<h.length-t;){const t={x0:this.coords[h[l-1]],y0:this.coords[h[l-1]+1],x1:this.coords[n[a+1]],y1:this.coords[n[a+1]+1]},e={x0:this.coords[h[l-s]],y0:this.coords[h[l-s]+1],x1:this.coords[h[l-1-s]],y1:this.coords[h[l-1-s]+1]},i=y(e,t,!0),r=e.x0===t.x0&&e.y0===t.y0,u=n[a+1]===o.coord&&e.x1===t.x1&&e.y1===t.y1;!isFinite(i.x)||r||u||(c=!0),s++}a++}if(this.cPoints=n.slice(),c)return this.concave(e,++i);if(r=n[a],h.push(r),L>1/0)return h;t.splice(t.indexOf(r),1),l++}let c=!0;for(const s of t)if(c=this.pointInOrOut([this.coords[s],this.coords[s+1]],h,0),!c)break;return c?(this.k=i,h):this.concave(e,++i)}sortByAngle(t,s,e){e=e&&e!==s?[this.coords[e],this.coords[e+1]]:[this.maxX.x+10,this.coords[s+1]],this.ray={x0:e[0],y0:e[1],x1:this.coords[s],y1:this.coords[s+1]};const i=[this.coords[s],this.coords[s+1]],n=v(this.coords,t,"polar",e,i).slice();let o,r;for(let t=0;t<n.length;t++){let s=[this.coords[n[t-1]],this.coords[n[t-1]+1]];0===t&&(s=i);const e=[this.coords[n[t]],this.coords[n[t]+1]],h=_(s,e),l=M(i,e);!isNaN(o)&&!isNaN(r)&&(Math.abs(h)===Math.abs(o)||h===1/0&&o===-1/0)&&l<r?(A(n,t,t-1),r=M(i,[this.coords[n[t]],this.coords[n[t]+1]])):r=l,o=_(s,e)}return n}nearestPoints(t,s,e){const i=[this.coords[s],this.coords[s+1]];t=v(this.coords.slice(),t.slice(),"euclid",i);const n=[];let o,r;e=Math.min(e,t.length-1);let h=0,l=0;if(1===t.length)return t;for(;l<e;){const s=_(i,[this.coords[t[h]],this.coords[t[h]+1]]),e=M(i,[this.coords[t[h]],this.coords[t[h]+1]]);if(e<=this.dist)if(e===r)n.push(t[h]);else if(s===o){const s=n[n.length-1];n[n.length-1]=t[h],n.push(s),l++}else 0!==l&&s===o||(n.push(t[h]),l++);if(h++,h>t.length-1)return n;o=s,r=e}return n}sortHeapAndClean(t,s,e,i,n){return s=v(t.slice(),s.slice(),e,i,n),s=this.clean(s)}clean(t){let s=0;const e=[];for(const i of t){for(let n=0;n<t.length;n++)if(this.coords[t[n]]===this.coords[i]&&this.coords[t[n]+1]===this.coords[i+1]&&s!==n){let s=!0;for(const i of e)this.coords[t[n]]===this.coords[i[0]]&&this.coords[t[n]+1]===this.coords[i[0]+1]&&(s=!1,i[1]++);s&&e.push([i,0]);break}s++}const i=[];for(let s=0;s<t.length;s++){let n=!0;for(const i of e)this.coords[t[s]]===this.coords[i[0]]&&this.coords[t[s]+1]===this.coords[i[0]+1]&&i[1]>0&&(i[1]--,n=!1);n&&i.push(t[s])}return i}calcCenter(){const t={x:0,y:0};for(let s=0;s<this.coords.length;s+=2)t.x+=this.coords[s],t.y+=this.coords[s+1];return t.x/=this.coords.length/2,t.y/=this.coords.length/2,t}pointInOrOut(t,s,e){const i=t[0]+this.maxD*Math.cos(e*Math.PI/180),n=t[1]+this.maxD*Math.sin(e*Math.PI/180),o={x0:t[0],y0:t[1],x1:i,y1:n};this.ray=o;let r=0,h={x:1/0,y:1/0};for(let i=0;i<s.length;i++){const n={x0:this.coords[s[i]],y0:this.coords[s[i]+1],x1:this.coords[s[i+1>s.length-1?0:i+1]],y1:this.coords[s[i+1>s.length-1?0:i+1]+1]},l=y(o,n,!0);if(isFinite(l.x)){const i=Math.round(1e6*l.x)===h.x&&Math.round(1e6*l.y)===h.y;if(n.y1-n.y0>0&&!i)r++;else if(n.y1-n.y0<0&&!i)r--;else if(i&&e<360)return this.pointInOrOut(t,s,++e);h={x:Math.round(1e6*l.x),y:Math.round(1e6*l.y)}}}return 0!==Math.abs(r)}printPoints(t){const s=[];for(const e of t)s.push(this.coords[e],this.coords[e+1]);console.log(s)}get hullCoords(){return this.subset(this.hull)}subset(t){const s=[];for(const e of t)s.push(this.coords[e],this.coords[e+1]);return s}get coords2D(){const t=[],s=this.sortedCoords;for(;s.length;)t.push(s.splice(0,2));return t}get sortedCoords(){const t=[];for(const s of this.hull)t.push(this.coords[s],this.coords[s+1]);return t}}{constructor(t,s=3,e=1/0){super(t,s,e),this.origCoordsLen=t.length,this.intersectingLineSegs=[],this.maxDist=e}addPoints(t,s,e){this.k=3;const i=g(s);for(let s=0;s<this.hull.length-1;s++){const n=this.subset([this.hull[s],this.hull[s+1]]),o={x0:n[0],y0:n[1],x1:n[2],y1:n[3]},r=this.getIntersectingLines(o,i,t,e).reverse(),h=v(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat(),[...Array(r.length).keys()].map(t=>2*t),"euclid",[o.x0,o.y0]);this.intersectingLineSegs.push(this.hull[s]);const l=this.coords.length;this.coords=this.coords.concat(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat()),this.intersectingLineSegs=this.intersectingLineSegs.concat(h.map(t=>t+l))}this.intersectingLineSegs.push(this.intersectingLineSegs[0]),this.hull=this.intersectingLineSegs,this.clean(this.hull)}getIntersectingLines(t,s,e,i,n=null){const o=[];for(let l=0;l<s.length;l+=2){const c={x:e[s[l]],y:e[s[l]+1]};if((r=t,h=c,Math.abs((r.y1-r.y0)*h.x-(r.x1-r.x0)*h.y+r.x1*r.y0-r.y1*r.x0)/Math.sqrt(Math.pow(r.y1-r.y0,2)+Math.pow(r.x1-r.x0,2)))<=i){l+1>s.length-1&&(l=-1);const i=y(t,{x0:c.x,y0:c.y,x1:e[s[l+1]],y1:e[s[l+1]+1]},!1);isFinite(i.x)&&(n&&n([s[l],s[l+1],i]),o.push([s[l],s[l+1],i]))}}var r,h;return o}get k(){return super.k}set k(t){super.k=t}}return class{constructor(t,s,i,...n){if(t&&Array.isArray(t[0])&&2===t[0].length)t=t.flat();else if(t&&Array.isArray(t[0])&&2!==t[0].length)return;this._delaunator=new e(t);const o=g(this._delaunator);let r=0,h=0;for(let s=0;s<o.length;s+=2)s===o.length-1?h+=M([t[o[s]],t[o[s]+1]],[t[o[0]],t[o[0]+1]]):h+=M([t[o[s]],t[o[s]+1]],[t[o[s+1]],t[o[s+1]+1]]),r+=1;let l=1/0;i&&(l=Math.ceil(h/r));const c=2*Math.ceil(h/r);this._boundaries=[],this.boundedDelaunators=[];for(let e of n)e&&Array.isArray(e[0])&&2===e[0].length&&(e=e.flat()),this._boundaries.push(new I(e,s)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,c),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]));this._boundaries.push(new I(t,s,l)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,c),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]))}setTrianglesInsideBound(t){let s=[];const i=[...this.delaunator.coords.keys()].filter(t=>t%2==0),n=k(this.delaunator.coords,i);for(const t of i){const e={x:this.delaunator.coords[t],y:this.delaunator.coords[t+1]};s.push(e.x,e.y)}console.log(s.length,i,s),s=s.concat(t.subset(t.hull));const o=new e(s),r=[];for(let s=0;s<o.triangles.length/3;s++){const e=3*s;let i=0,h=0;for(let t=0;t<3;t++)i+=o.coords[2*o.triangles[t+e]],h+=o.coords[2*o.triangles[t+e]+1];const l={x:i/3,y:h/3};t.pointInOrOut([l.x,l.y],t.hull,n.x+10)&&r.push(o.triangles[e],o.triangles[e+1],o.triangles[e+2])}return o.triangles=new o.triangles.constructor(r),o}update(t){const s=this.coords;for(const e of t.flat())s.push(e);this._delaunator=new e(s)}get coords2D(){const t=[],s=this.coords;for(let e=0;e<s.length;e+=2)t.push([s[e],s[e+1]]);return t}get coords(){return this.delaunator.coords}get triangles(){return this.delaunator.triangles}get hull(){return this.delaunator.hull}get delaunator(){return this._delaunator}get boundaries(){return this._boundaries}get holes(){return this.boundedDelaunators}}}));

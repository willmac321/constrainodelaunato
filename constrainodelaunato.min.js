!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):(t=t||self).ConstrainoDelaunato=s()}(this,(function(){"use strict";const t=Math.pow(2,-52),s=new Uint32Array(512);class i{static from(t,s=a,e=u){const n=t.length,o=new Float64Array(2*n);for(let i=0;i<n;i++){const n=t[i];o[2*i]=s(n),o[2*i+1]=e(n)}return new i(o)}constructor(t){const s=t.length>>1;if(s>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;const i=Math.max(2*s-5,0);this._triangles=new Uint32Array(3*i),this._halfedges=new Int32Array(3*i),this._hashSize=Math.ceil(Math.sqrt(s)),this._hullPrev=new Uint32Array(s),this._hullNext=new Uint32Array(s),this._hullTri=new Uint32Array(s),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(s),this._dists=new Float64Array(s),this.update()}update(){const{coords:s,_hullPrev:i,_hullNext:n,_hullTri:r,_hullHash:c}=this,a=s.length>>1;let u=1/0,d=1/0,f=-1/0,g=-1/0;for(let t=0;t<a;t++){const i=s[2*t],e=s[2*t+1];i<u&&(u=i),e<d&&(d=e),i>f&&(f=i),e>g&&(g=e),this._ids[t]=t}const y=(u+f)/2,x=(d+g)/2;let _,p,b,M=1/0;for(let t=0;t<a;t++){const i=e(y,x,s[2*t],s[2*t+1]);i<M&&(_=t,M=i)}const w=s[2*_],m=s[2*_+1];M=1/0;for(let t=0;t<a;t++){if(t===_)continue;const i=e(w,m,s[2*t],s[2*t+1]);i<M&&i>0&&(p=t,M=i)}let A=s[2*p],k=s[2*p+1],S=1/0;for(let t=0;t<a;t++){if(t===_||t===p)continue;const i=h(w,m,A,k,s[2*t],s[2*t+1]);i<S&&(b=t,S=i)}let v=s[2*b],I=s[2*b+1];if(S===1/0){for(let t=0;t<a;t++)this._dists[t]=s[2*t]-s[0]||s[2*t+1]-s[1];l(this._ids,this._dists,0,a-1);const t=new Uint32Array(a);let i=0;for(let s=0,e=-1/0;s<a;s++){const n=this._ids[s];this._dists[n]>e&&(t[i++]=n,e=this._dists[n])}return this.hull=t.subarray(0,i),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(o(w,m,A,k,v,I)){const t=p,s=A,i=k;p=b,A=v,k=I,b=t,v=s,I=i}const L=function(t,s,i,e,n,o){const r=i-t,h=e-s,l=n-t,c=o-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l);return{x:t+(c*a-h*u)*d,y:s+(r*u-l*a)*d}}(w,m,A,k,v,I);this._cx=L.x,this._cy=L.y;for(let t=0;t<a;t++)this._dists[t]=e(s[2*t],s[2*t+1],L.x,L.y);l(this._ids,this._dists,0,a-1),this._hullStart=_;let P=3;n[_]=i[b]=p,n[p]=i[_]=b,n[b]=i[p]=_,r[_]=0,r[p]=1,r[b]=2,c.fill(-1),c[this._hashKey(w,m)]=_,c[this._hashKey(A,k)]=p,c[this._hashKey(v,I)]=b,this.trianglesLen=0,this._addTriangle(_,p,b,-1,-1,-1);for(let e,h,l=0;l<this._ids.length;l++){const a=this._ids[l],u=s[2*a],d=s[2*a+1];if(l>0&&Math.abs(u-e)<=t&&Math.abs(d-h)<=t)continue;if(e=u,h=d,a===_||a===p||a===b)continue;let f=0;for(let t=0,s=this._hashKey(u,d);t<this._hashSize&&(f=c[(s+t)%this._hashSize],-1===f||f===n[f]);t++);f=i[f];let g,y=f;for(;g=n[y],!o(u,d,s[2*y],s[2*y+1],s[2*g],s[2*g+1]);)if(y=g,y===f){y=-1;break}if(-1===y)continue;let x=this._addTriangle(y,a,n[y],-1,-1,r[y]);r[a]=this._legalize(x+2),r[y]=x,P++;let M=n[y];for(;g=n[M],o(u,d,s[2*M],s[2*M+1],s[2*g],s[2*g+1]);)x=this._addTriangle(M,a,g,r[a],-1,r[M]),r[a]=this._legalize(x+2),n[M]=M,P--,M=g;if(y===f)for(;g=i[y],o(u,d,s[2*g],s[2*g+1],s[2*y],s[2*y+1]);)x=this._addTriangle(g,a,y,-1,r[y],r[g]),this._legalize(x+2),r[g]=x,n[y]=y,P--,y=g;this._hullStart=i[a]=y,n[y]=i[M]=a,n[a]=M,c[this._hashKey(u,d)]=a,c[this._hashKey(s[2*y],s[2*y+1])]=y}this.hull=new Uint32Array(P);for(let t=0,s=this._hullStart;t<P;t++)this.hull[t]=s,s=n[s];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,s){return Math.floor(function(t,s){const i=t/(Math.abs(t)+Math.abs(s));return(s>0?3-i:1+i)/4}(t-this._cx,s-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:i,_halfedges:e,coords:n}=this;let o=0,h=0;for(;;){const l=e[t],c=t-t%3;if(h=c+(t+2)%3,-1===l){if(0===o)break;t=s[--o];continue}const a=l-l%3,u=c+(t+1)%3,d=a+(l+2)%3,f=i[h],g=i[t],y=i[u],x=i[d];if(r(n[2*f],n[2*f+1],n[2*g],n[2*g+1],n[2*y],n[2*y+1],n[2*x],n[2*x+1])){i[t]=x,i[l]=f;const n=e[d];if(-1===n){let s=this._hullStart;do{if(this._hullTri[s]===d){this._hullTri[s]=t;break}s=this._hullPrev[s]}while(s!==this._hullStart)}this._link(t,n),this._link(l,e[h]),this._link(h,d);const r=a+(l+1)%3;o<s.length&&(s[o++]=r)}else{if(0===o)break;t=s[--o]}}return h}_link(t,s){this._halfedges[t]=s,-1!==s&&(this._halfedges[s]=t)}_addTriangle(t,s,i,e,n,o){const r=this.trianglesLen;return this._triangles[r]=t,this._triangles[r+1]=s,this._triangles[r+2]=i,this._link(r,e),this._link(r+1,n),this._link(r+2,o),this.trianglesLen+=3,r}}function e(t,s,i,e){const n=t-i,o=s-e;return n*n+o*o}function n(t,s,i,e,n,o){const r=(e-s)*(n-t),h=(i-t)*(o-s);return Math.abs(r-h)>=33306690738754716e-32*Math.abs(r+h)?r-h:0}function o(t,s,i,e,o,r){return(n(o,r,t,s,i,e)||n(t,s,i,e,o,r)||n(i,e,o,r,t,s))<0}function r(t,s,i,e,n,o,r,h){const l=t-r,c=s-h,a=i-r,u=e-h,d=n-r,f=o-h,g=a*a+u*u,y=d*d+f*f;return l*(u*y-g*f)-c*(a*y-g*d)+(l*l+c*c)*(a*f-u*d)<0}function h(t,s,i,e,n,o){const r=i-t,h=e-s,l=n-t,c=o-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l),f=(c*a-h*u)*d,g=(r*u-l*a)*d;return f*f+g*g}function l(t,s,i,e){if(e-i<=20)for(let n=i+1;n<=e;n++){const e=t[n],o=s[e];let r=n-1;for(;r>=i&&s[t[r]]>o;)t[r+1]=t[r--];t[r+1]=e}else{let n=i+1,o=e;c(t,i+e>>1,n),s[t[i]]>s[t[e]]&&c(t,i,e),s[t[n]]>s[t[e]]&&c(t,n,e),s[t[i]]>s[t[n]]&&c(t,i,n);const r=t[n],h=s[r];for(;;){do{n++}while(s[t[n]]<h);do{o--}while(s[t[o]]>h);if(o<n)break;c(t,n,o)}t[i+1]=t[o],t[o]=r,e-n+1>=o-i?(l(t,s,n,e),l(t,s,i,o-1)):(l(t,s,i,o-1),l(t,s,n,e))}}function c(t,s,i){const e=t[s];t[s]=t[i],t[i]=e}function a(t){return t[0]}function u(t){return t[1]}var d;function f(t){return t%3==2?t-2:t+1}function g(t){const s=[];for(let i=0;i<t.triangles.length;i++)i>t.halfedges[i]&&s.push(2*t.triangles[i],2*t.triangles[f(i)]);return s}function y(t,s,i=!1){const e=(s.y1-s.y0)*(t.x1-t.x0)-(s.x1-s.x0)*(t.y1-t.y0);if(0===e)return{x:1/0,y:1/0};let n=t.y0-s.y0,o=t.x0-s.x0;const r=(s.x1-s.x0)*n-(s.y1-s.y0)*o,h=(t.x1-t.x0)*n-(t.y1-t.y0)*o;n=r/e,o=h/e;const l={x:t.x0+n*(t.x1-t.x0),y:t.y0+n*(t.y1-t.y0)};let c=function(t,s){const i={a:!1,b:!1};t>0&&t<1&&(i.a=!0);s>0&&s<1&&(i.b=!0);return i}(n,o);return i&&(c=function(t,s){const i={a:!1,b:!1};t>=0&&t<=1&&(i.a=!0);s>=0&&s<=1&&(i.b=!0);return i}(n,o)),c.a&&c.b?l:{x:1/0,y:1/0}}function x(t,s){const i=t[0],e=t[1];return i*s[0]+e*s[1]}function _(t,s){const i=t[0],e=t[1],n=s[0];return(e-s[1])/(i-n)}function p(t,s){const i={x:t[0]-d.x,y:t[1]-d.y},e={x:s[0]-d.x,y:s[1]-d.y},n=Math.sqrt(Math.pow(i.x,2)+Math.pow(i.y,2)),o=Math.sqrt(Math.pow(e.x,2)+Math.pow(e.y,2));let r=180*Math.acos((e.x*i.x+e.y*i.y)/(n*o))/Math.PI;const h=i.x*e.y-e.x*i.y;return r=isNaN(r)?0:r,r=h>0?360-r:r,r}function b(t,s){const i=t[0],e=t[1],n=s[0],o=s[1];return Math.abs(i-n)+Math.abs(e-o)}function M(t,s){const i=t[0],e=t[1],n=s[0],o=s[1];return Math.sqrt(Math.pow(i-n,2)+Math.pow(e-o,2))}function w(t,s,i,e,n,o){let r;"dist"===n?r=b:"distrel"===n?r=b:"euclid"===n?r=M:"polar"===n?(r=p,d={x:o[0],y:o[1]}):"dot"===n?r=x:Array.isArray(i[0])?r=x:(t=t[0],r=(t,s)=>t-s),function(t,s,i,e,n,o){let r=(h=e-1,Math.floor((h-1)/2));var h;for(;r>=0;)m(t,s,i,r,e-1,n,o),r--}(t,i,s,e,r,n);let h=e-1;for(;h>0;)A(s,h,0),h--,m(t,i,s,0,h,r,n)}function m(t,s,i,e,n,o,r){let h=e;const l=t=>2*t+1;for(;l(h)<=n;){const e=l(h);let c=h;const a=e=>{const n=o([s[i[e]],s[i[e]+1]],t);return"distrel"===r&&(t=[s[i[e]],s[i[e]+1]]),n};if(a(c)<a(e)&&(c=e),e+1<=n&&a(c)<a(e+1)&&(c=e+1),c===h)return;A(i,h,c),h=c}}function A(t,s,i){const e=t[s];t[s]=t[i],t[i]=e}function k(t,s){let i=0,e=-1/0,n=-1/0;if(s)for(const[o,r]of s.entries())t[r]>n?(n=t[r],e=t[r+1],i=o):t[r+1]>=e&&t[r]>=n&&(n=t[r],e=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]>n&&(n=t[s],i=s);return{x:n,y:e,i:i}}function S(t,s){let i=0,e=1/0,n=1/0;if(s)for(const[o,r]of s.entries())t[r+1]<e?(n=t[r],e=t[r+1],i=o):t[r+1]<=e&&t[r]<=n&&(n=t[r],e=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]<n&&(n=t[s],i=s);return{x:n,y:e,i:i}}function v(t,s,i,e,n){return w(e,s,t,s.length,i,n),s}var I=0;class L extends class{constructor(t,s=3,i){this.k=s,this.dist=i,this.coords=t.slice(),this.index=[...this.coords.keys()].filter(t=>t%2==0),this.index=this.clean(this.index),this.center=this.calcCenter(),this.minY=S(this.coords,this.index),this.maxY=function(t,s){let i=0,e=-1/0,n=-1/0;if(s)for(const[o,r]of s.entries())t[r+1]>e?(n=t[r],e=t[r+1],i=o):t[r+1]>=e&&t[r]>=n&&(n=t[r],e=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]>n&&(n=t[s],i=s);return{x:n,y:e,i:i}}(this.coords,this.index),this.minX=function(t,s){let i=0,e=1/0,n=1/0;if(s)for(const[o,r]of s.entries())t[r]<n?(n=t[r],e=t[r+1],i=o):t[r+1]<=e&&t[r]<=n&&(n=t[r],e=t[r+1],i=o);else for(let s=0;s<t.length;s++)t[s]<n&&(n=t[s],i=s);return{x:n,y:e,i:i}}(this.coords,this.index),this.maxX=k(this.coords,this.index),this.maxD=Math.sqrt(Math.pow(this.maxX.x-this.minX.x,2)+Math.pow(this.maxY.y-this.minY.y,2)),this.offsetAngle=1,this.cPoints=[],this.ray=null,this.hull=this.findConcaveHull(s)}findConcaveHull(t){const s=this.sortHeapAndClean(this.coords,this.index,"polar",[this.minX.x,this.minY.y],[this.center.x,this.center.y]),i=[...s];let e=this.concave(s,t);return null===e&&(this.dist=1/0,e=this.concave(i,t)),e}concave(t,s){const i=t.slice();if(t.length<3)return console.error(`Remaining points can not form a polygon k:${s}`),null;if(s>t.length-1)return console.error(`K exceeds total length of points available k:${s}`),null;if(3===t.length)return t;let e=Math.min(Math.max(s,3),t.length-1);const n=S(this.coords,t).i,o={i:n,coord:t[n]};let r=o.coord;const h=[o.coord];let l=1;for(t.splice(o.i,1);(r!==o.coord||1===l)&&t.length>0;){I++,4===l&&t.indexOf(o.coord)<0?t.push(o.coord):l<=i.length-1&&l<4&&1===t.length&&t.indexOf(o.coord)<0&&t.push(o.coord);const s=this.nearestPoints(t,r,e),n=this.sortByAngle(s,r,h[h.length-2]);let c=!0,a=-1;for(;c&&a<n.length-1;){let t=0;n[a]===o.coord&&(t=1);let s=1;for(c=!1;!c&&s<h.length-t;){const t={x0:this.coords[h[l-1]],y0:this.coords[h[l-1]+1],x1:this.coords[n[a+1]],y1:this.coords[n[a+1]+1]},i={x0:this.coords[h[l-s]],y0:this.coords[h[l-s]+1],x1:this.coords[h[l-1-s]],y1:this.coords[h[l-1-s]+1]},e=y(i,t,!0),r=i.x0===t.x0&&i.y0===t.y0,u=n[a+1]===o.coord&&i.x1===t.x1&&i.y1===t.y1;!isFinite(e.x)||r||u||(c=!0),s++}a++}if(this.cPoints=n.slice(),c)return this.concave(i,++e);if(r=n[a],h.push(r),I>1/0)return h;t.splice(t.indexOf(r),1),l++}let c=!0;for(const s of t)if(c=this.pointInOrOut([this.coords[s],this.coords[s+1]],h,0),!c)break;return c?(this.k=e,h):this.concave(i,++e)}sortByAngle(t,s,i){i=i&&i!==s?[this.coords[i],this.coords[i+1]]:[this.maxX.x+10,this.coords[s+1]],this.ray={x0:i[0],y0:i[1],x1:this.coords[s],y1:this.coords[s+1]};const e=[this.coords[s],this.coords[s+1]],n=v(this.coords,t,"polar",i,e).slice();let o,r;for(let t=0;t<n.length;t++){let s=[this.coords[n[t-1]],this.coords[n[t-1]+1]];0===t&&(s=e);const i=[this.coords[n[t]],this.coords[n[t]+1]],h=_(s,i),l=M(e,i);!isNaN(o)&&!isNaN(r)&&(Math.abs(h)===Math.abs(o)||h===1/0&&o===-1/0)&&l<r?(A(n,t,t-1),r=M(e,[this.coords[n[t]],this.coords[n[t]+1]])):r=l,o=_(s,i)}return n}nearestPoints(t,s,i){const e=[this.coords[s],this.coords[s+1]];t=v(this.coords.slice(),t.slice(),"euclid",e);const n=[];let o,r;i=Math.min(i,t.length-1);let h=0,l=0;if(1===t.length)return t;for(;l<i;){const s=_(e,[this.coords[t[h]],this.coords[t[h]+1]]),i=M(e,[this.coords[t[h]],this.coords[t[h]+1]]);if(i<=this.dist)if(i===r)n.push(t[h]);else if(s===o){const s=n[n.length-1];n[n.length-1]=t[h],n.push(s),l++}else 0!==l&&s===o||(n.push(t[h]),l++);if(h++,h>t.length-1)return n;o=s,r=i}return n}sortHeapAndClean(t,s,i,e,n){return s=v(t.slice(),s.slice(),i,e,n),s=this.clean(s)}clean(t){let s=0;const i=[];for(const e of t){for(let n=0;n<t.length;n++)if(this.coords[t[n]]===this.coords[e]&&this.coords[t[n]+1]===this.coords[e+1]&&s!==n){let s=!0;for(const e of i)this.coords[t[n]]===this.coords[e[0]]&&this.coords[t[n]+1]===this.coords[e[0]+1]&&(s=!1,e[1]++);s&&i.push([e,0]);break}s++}const e=[];for(let s=0;s<t.length;s++){let n=!0;for(const e of i)this.coords[t[s]]===this.coords[e[0]]&&this.coords[t[s]+1]===this.coords[e[0]+1]&&e[1]>0&&(e[1]--,n=!1);n&&e.push(t[s])}return e}calcCenter(){const t={x:0,y:0};for(let s=0;s<this.coords.length;s+=2)t.x+=this.coords[s],t.y+=this.coords[s+1];return t.x/=this.coords.length/2,t.y/=this.coords.length/2,t}pointInOrOut(t,s,i){const e=t[0]+this.maxD*Math.cos(i*Math.PI/180),n=t[1]+this.maxD*Math.sin(i*Math.PI/180),o={x0:t[0],y0:t[1],x1:e,y1:n};this.ray=o;let r=0,h={x:1/0,y:1/0};for(let e=0;e<s.length;e++){const n={x0:this.coords[s[e]],y0:this.coords[s[e]+1],x1:this.coords[s[e+1>s.length-1?0:e+1]],y1:this.coords[s[e+1>s.length-1?0:e+1]+1]},l=y(o,n,!0);if(isFinite(l.x)){const e=Math.round(1e6*l.x)===h.x&&Math.round(1e6*l.y)===h.y;if(n.y1-n.y0>0&&!e)r++;else if(n.y1-n.y0<0&&!e)r--;else if(e&&i<360)return this.pointInOrOut(t,s,++i);h={x:Math.round(1e6*l.x),y:Math.round(1e6*l.y)}}}return 0!==Math.abs(r)}printPoints(t){const s=[];for(const i of t)s.push(this.coords[i],this.coords[i+1]);console.log(s)}get hullCoords(){return this.subset(this.hull)}subset(t){const s=[];for(const i of t)s.push(this.coords[i],this.coords[i+1]);return s}get coords2D(){const t=[],s=this.sortedCoords;for(;s.length;)t.push(s.splice(0,2));return t}get sortedCoords(){const t=[];for(const s of this.hull)t.push(this.coords[s],this.coords[s+1]);return t}}{constructor(t,s=3,i=1/0){super(t,s,i),this.origCoordsLen=t.length,this.intersectingLineSegs=[],this.maxDist=i}addPoints(t,s,i){this.k=3;const e=g(s);for(let s=0;s<this.hull.length-1;s++){const n=this.subset([this.hull[s],this.hull[s+1]]),o={x0:n[0],y0:n[1],x1:n[2],y1:n[3]},r=this.getIntersectingLines(o,e,t,i).reverse(),h=v(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat(),[...Array(r.length).keys()].map(t=>2*t),"euclid",[o.x0,o.y0]);this.intersectingLineSegs.push(this.hull[s]);const l=this.coords.length;this.coords=this.coords.concat(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat()),this.intersectingLineSegs=this.intersectingLineSegs.concat(h.map(t=>t+l))}this.intersectingLineSegs.push(this.intersectingLineSegs[0]),this.hull=this.intersectingLineSegs,this.clean(this.hull)}getIntersectingLines(t,s,i,e,n=null){const o=[];for(let l=0;l<s.length;l+=2){const c={x:i[s[l]],y:i[s[l]+1]};if((r=t,h=c,Math.abs((r.y1-r.y0)*h.x-(r.x1-r.x0)*h.y+r.x1*r.y0-r.y1*r.x0)/Math.sqrt(Math.pow(r.y1-r.y0,2)+Math.pow(r.x1-r.x0,2)))<=e){l+1>s.length-1&&(l=-1);const e=y(t,{x0:c.x,y0:c.y,x1:i[s[l+1]],y1:i[s[l+1]+1]},!1);isFinite(e.x)&&(n&&n([s[l],s[l+1],e]),o.push([s[l],s[l+1],e]))}}var r,h;return o}get k(){return super.k}set k(t){super.k=t}}return class{constructor(t,s,...e){if(t&&Array.isArray(t[0])&&2===t[0].length)t=t.flat();else if(t&&Array.isArray(t[0])&&2!==t[0].length)return;this._delaunator=new i(t);const n=g(this._delaunator);let o=0,r=0;for(let s=0;s<n.length;s+=2)s===n.length-1?r+=M([t[n[s]],t[n[s]+1]],[t[n[0]],t[n[0]+1]]):r+=M([t[n[s]],t[n[s]+1]],[t[n[s+1]],t[n[s+1]+1]]),o+=1;const h=Math.ceil(r/o),l=2*h;this._boundaries=[],this.boundedDelaunators=[];for(let i of e)i&&Array.isArray(i[0])&&2===i[0].length&&(i=i.flat()),this._boundaries.push(new L(i,s)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,l),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]));this._boundaries.push(new L(t,s,h)),this._boundaries[this._boundaries.length-1].addPoints(t,this._delaunator,l),this.boundedDelaunators.push(this.setTrianglesInsideBound(this._boundaries[this._boundaries.length-1]))}setTrianglesInsideBound(t){let s=[];const e=[...this.delaunator.coords.keys()].filter(t=>t%2==0),n=k(this.delaunator.coords,e);for(const i of e){const e={x:this.delaunator.coords[i],y:this.delaunator.coords[i+1]};t.pointInOrOut([e.x,e.y],t.hull,n.x+10)&&s.push(e.x,e.y)}s=s.concat(t.subset(t.hull));const o=new i(s),r=[];for(let s=0;s<o.triangles.length/3;s++){const i=3*s;let e=0,h=0;for(let t=0;t<3;t++)e+=o.coords[2*o.triangles[t+i]],h+=o.coords[2*o.triangles[t+i]+1];const l={x:e/3,y:h/3};t.pointInOrOut([l.x,l.y],t.hull,n.x+10)&&r.push(o.triangles[i],o.triangles[i+1],o.triangles[i+2])}return o.triangles=new o.triangles.constructor(r),o}update(t){const s=this.coords;for(const i of t.flat())s.push(i);this._delaunator=new i(s)}get coords2D(){const t=[],s=this.coords;for(let i=0;i<s.length;i+=2)t.push([s[i],s[i+1]]);return t}get coords(){return this.delaunator.coords}get triangles(){return this.delaunator.triangles}get hull(){return this.delaunator.hull}get delaunator(){return this._delaunator}get boundaries(){return this._boundaries}get holes(){return this.boundedDelaunators}}}));

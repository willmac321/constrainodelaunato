!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):(t=t||self).ConstrainoDelaunato=s()}(this,(function(){"use strict";const t=Math.pow(2,-52),s=new Uint32Array(512);class n{static from(t,s=a,o=u){const e=t.length,i=new Float64Array(2*e);for(let n=0;n<e;n++){const e=t[n];i[2*n]=s(e),i[2*n+1]=o(e)}return new n(i)}constructor(t){const s=t.length>>1;if(s>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;const n=Math.max(2*s-5,0);this._triangles=new Uint32Array(3*n),this._halfedges=new Int32Array(3*n),this._hashSize=Math.ceil(Math.sqrt(s)),this._hullPrev=new Uint32Array(s),this._hullNext=new Uint32Array(s),this._hullTri=new Uint32Array(s),this._hullHash=new Int32Array(this._hashSize).fill(-1),this._ids=new Uint32Array(s),this._dists=new Float64Array(s),this.update()}update(){const{coords:s,_hullPrev:n,_hullNext:e,_hullTri:r,_hullHash:c}=this,a=s.length>>1;let u=1/0,d=1/0,f=-1/0,g=-1/0;for(let t=0;t<a;t++){const n=s[2*t],o=s[2*t+1];n<u&&(u=n),o<d&&(d=o),n>f&&(f=n),o>g&&(g=o),this._ids[t]=t}const y=(u+f)/2,x=(d+g)/2;let _,p,b,M=1/0;for(let t=0;t<a;t++){const n=o(y,x,s[2*t],s[2*t+1]);n<M&&(_=t,M=n)}const w=s[2*_],A=s[2*_+1];M=1/0;for(let t=0;t<a;t++){if(t===_)continue;const n=o(w,A,s[2*t],s[2*t+1]);n<M&&n>0&&(p=t,M=n)}let k=s[2*p],m=s[2*p+1],S=1/0;for(let t=0;t<a;t++){if(t===_||t===p)continue;const n=h(w,A,k,m,s[2*t],s[2*t+1]);n<S&&(b=t,S=n)}let v=s[2*b],L=s[2*b+1];if(S===1/0){for(let t=0;t<a;t++)this._dists[t]=s[2*t]-s[0]||s[2*t+1]-s[1];l(this._ids,this._dists,0,a-1);const t=new Uint32Array(a);let n=0;for(let s=0,o=-1/0;s<a;s++){const e=this._ids[s];this._dists[e]>o&&(t[n++]=e,o=this._dists[e])}return this.hull=t.subarray(0,n),this.triangles=new Uint32Array(0),void(this.halfedges=new Uint32Array(0))}if(i(w,A,k,m,v,L)){const t=p,s=k,n=m;p=b,k=v,m=L,b=t,v=s,L=n}const P=function(t,s,n,o,e,i){const r=n-t,h=o-s,l=e-t,c=i-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l);return{x:t+(c*a-h*u)*d,y:s+(r*u-l*a)*d}}(w,A,k,m,v,L);this._cx=P.x,this._cy=P.y;for(let t=0;t<a;t++)this._dists[t]=o(s[2*t],s[2*t+1],P.x,P.y);l(this._ids,this._dists,0,a-1),this._hullStart=_;let I=3;e[_]=n[b]=p,e[p]=n[_]=b,e[b]=n[p]=_,r[_]=0,r[p]=1,r[b]=2,c.fill(-1),c[this._hashKey(w,A)]=_,c[this._hashKey(k,m)]=p,c[this._hashKey(v,L)]=b,this.trianglesLen=0,this._addTriangle(_,p,b,-1,-1,-1);for(let o,h,l=0;l<this._ids.length;l++){const a=this._ids[l],u=s[2*a],d=s[2*a+1];if(l>0&&Math.abs(u-o)<=t&&Math.abs(d-h)<=t)continue;if(o=u,h=d,a===_||a===p||a===b)continue;let f=0;for(let t=0,s=this._hashKey(u,d);t<this._hashSize&&(f=c[(s+t)%this._hashSize],-1===f||f===e[f]);t++);f=n[f];let g,y=f;for(;g=e[y],!i(u,d,s[2*y],s[2*y+1],s[2*g],s[2*g+1]);)if(y=g,y===f){y=-1;break}if(-1===y)continue;let x=this._addTriangle(y,a,e[y],-1,-1,r[y]);r[a]=this._legalize(x+2),r[y]=x,I++;let M=e[y];for(;g=e[M],i(u,d,s[2*M],s[2*M+1],s[2*g],s[2*g+1]);)x=this._addTriangle(M,a,g,r[a],-1,r[M]),r[a]=this._legalize(x+2),e[M]=M,I--,M=g;if(y===f)for(;g=n[y],i(u,d,s[2*g],s[2*g+1],s[2*y],s[2*y+1]);)x=this._addTriangle(g,a,y,-1,r[y],r[g]),this._legalize(x+2),r[g]=x,e[y]=y,I--,y=g;this._hullStart=n[a]=y,e[y]=n[M]=a,e[a]=M,c[this._hashKey(u,d)]=a,c[this._hashKey(s[2*y],s[2*y+1])]=y}this.hull=new Uint32Array(I);for(let t=0,s=this._hullStart;t<I;t++)this.hull[t]=s,s=e[s];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(t,s){return Math.floor(function(t,s){const n=t/(Math.abs(t)+Math.abs(s));return(s>0?3-n:1+n)/4}(t-this._cx,s-this._cy)*this._hashSize)%this._hashSize}_legalize(t){const{_triangles:n,_halfedges:o,coords:e}=this;let i=0,h=0;for(;;){const l=o[t],c=t-t%3;if(h=c+(t+2)%3,-1===l){if(0===i)break;t=s[--i];continue}const a=l-l%3,u=c+(t+1)%3,d=a+(l+2)%3,f=n[h],g=n[t],y=n[u],x=n[d];if(r(e[2*f],e[2*f+1],e[2*g],e[2*g+1],e[2*y],e[2*y+1],e[2*x],e[2*x+1])){n[t]=x,n[l]=f;const e=o[d];if(-1===e){let s=this._hullStart;do{if(this._hullTri[s]===d){this._hullTri[s]=t;break}s=this._hullPrev[s]}while(s!==this._hullStart)}this._link(t,e),this._link(l,o[h]),this._link(h,d);const r=a+(l+1)%3;i<s.length&&(s[i++]=r)}else{if(0===i)break;t=s[--i]}}return h}_link(t,s){this._halfedges[t]=s,-1!==s&&(this._halfedges[s]=t)}_addTriangle(t,s,n,o,e,i){const r=this.trianglesLen;return this._triangles[r]=t,this._triangles[r+1]=s,this._triangles[r+2]=n,this._link(r,o),this._link(r+1,e),this._link(r+2,i),this.trianglesLen+=3,r}}function o(t,s,n,o){const e=t-n,i=s-o;return e*e+i*i}function e(t,s,n,o,e,i){const r=(o-s)*(e-t),h=(n-t)*(i-s);return Math.abs(r-h)>=33306690738754716e-32*Math.abs(r+h)?r-h:0}function i(t,s,n,o,i,r){return(e(i,r,t,s,n,o)||e(t,s,n,o,i,r)||e(n,o,i,r,t,s))<0}function r(t,s,n,o,e,i,r,h){const l=t-r,c=s-h,a=n-r,u=o-h,d=e-r,f=i-h,g=a*a+u*u,y=d*d+f*f;return l*(u*y-g*f)-c*(a*y-g*d)+(l*l+c*c)*(a*f-u*d)<0}function h(t,s,n,o,e,i){const r=n-t,h=o-s,l=e-t,c=i-s,a=r*r+h*h,u=l*l+c*c,d=.5/(r*c-h*l),f=(c*a-h*u)*d,g=(r*u-l*a)*d;return f*f+g*g}function l(t,s,n,o){if(o-n<=20)for(let e=n+1;e<=o;e++){const o=t[e],i=s[o];let r=e-1;for(;r>=n&&s[t[r]]>i;)t[r+1]=t[r--];t[r+1]=o}else{let e=n+1,i=o;c(t,n+o>>1,e),s[t[n]]>s[t[o]]&&c(t,n,o),s[t[e]]>s[t[o]]&&c(t,e,o),s[t[n]]>s[t[e]]&&c(t,n,e);const r=t[e],h=s[r];for(;;){do{e++}while(s[t[e]]<h);do{i--}while(s[t[i]]>h);if(i<e)break;c(t,e,i)}t[n+1]=t[i],t[i]=r,o-e+1>=i-n?(l(t,s,e,o),l(t,s,n,i-1)):(l(t,s,n,i-1),l(t,s,e,o))}}function c(t,s,n){const o=t[s];t[s]=t[n],t[n]=o}function a(t){return t[0]}function u(t){return t[1]}var d;function f(t){return t%3==2?t-2:t+1}function g(t,s,n=!1){const o=(s.y1-s.y0)*(t.x1-t.x0)-(s.x1-s.x0)*(t.y1-t.y0);if(0===o)return{x:1/0,y:1/0};let e=t.y0-s.y0,i=t.x0-s.x0;const r=(s.x1-s.x0)*e-(s.y1-s.y0)*i,h=(t.x1-t.x0)*e-(t.y1-t.y0)*i;e=r/o,i=h/o;const l={x:t.x0+e*(t.x1-t.x0),y:t.y0+e*(t.y1-t.y0)};let c=function(t,s){const n={a:!1,b:!1};t>0&&t<1&&(n.a=!0);s>0&&s<1&&(n.b=!0);return n}(e,i);return n&&(c=function(t,s){const n={a:!1,b:!1};t>=0&&t<=1&&(n.a=!0);s>=0&&s<=1&&(n.b=!0);return n}(e,i)),c.a&&c.b?l:{x:1/0,y:1/0}}function y(t,s){const n=t[0],o=t[1];return n*s[0]+o*s[1]}function x(t,s){const n=t[0],o=t[1],e=s[0];return(o-s[1])/(n-e)}function _(t,s){const n={x:t[0]-d.x,y:t[1]-d.y},o={x:s[0]-d.x,y:s[1]-d.y},e=Math.sqrt(Math.pow(n.x,2)+Math.pow(n.y,2)),i=Math.sqrt(Math.pow(o.x,2)+Math.pow(o.y,2));let r=180*Math.acos((o.x*n.x+o.y*n.y)/(e*i))/Math.PI;const h=n.x*o.y-o.x*n.y;return r=isNaN(r)?0:r,r=h>0?360-r:r,r}function p(t,s){const n=t[0],o=t[1],e=s[0],i=s[1];return Math.abs(n-e)+Math.abs(o-i)}function b(t,s){const n=t[0],o=t[1],e=s[0],i=s[1];return Math.sqrt(Math.pow(n-e,2)+Math.pow(o-i,2))}function M(t,s,n,o,e,i){let r;"dist"===e?r=p:"distrel"===e?r=p:"euclid"===e?r=b:"polar"===e?(r=_,d={x:i[0],y:i[1]}):"dot"===e?r=y:Array.isArray(n[0])?r=y:(t=t[0],r=(t,s)=>t-s),function(t,s,n,o,e,i){let r=(h=o-1,Math.floor((h-1)/2));var h;for(;r>=0;)w(t,s,n,r,o-1,e,i),r--}(t,n,s,o,r,e);let h=o-1;for(;h>0;)A(s,h,0),h--,w(t,n,s,0,h,r,e)}function w(t,s,n,o,e,i,r){let h=o;const l=t=>2*t+1;for(;l(h)<=e;){const o=l(h);let c=h;const a=o=>{const e=i([s[n[o]],s[n[o]+1]],t);return"distrel"===r&&(t=[s[n[o]],s[n[o]+1]]),e};if(a(c)<a(o)&&(c=o),o+1<=e&&a(c)<a(o+1)&&(c=o+1),c===h)return;A(n,h,c),h=c}}function A(t,s,n){const o=t[s];t[s]=t[n],t[n]=o}function k(t,s){let n=0,o=-1/0,e=-1/0;if(s)for(const[i,r]of s.entries())t[r]>e?(e=t[r],o=t[r+1],n=i):t[r+1]>=o&&t[r]>=e&&(e=t[r],o=t[r+1],n=i);else for(let s=0;s>t.length;s++)t[s]>e&&(e=t[s],n=s);return{x:e,y:o,i:n}}function m(t,s){let n=0,o=1/0,e=1/0;if(s)for(const[i,r]of s.entries())t[r+1]<o?(e=t[r],o=t[r+1],n=i):t[r+1]<=o&&t[r]<=e&&(e=t[r],o=t[r+1],n=i);else for(let s=0;s<t.length;s++)t[s]<e&&(e=t[s],n=s);return{x:e,y:o,i:n}}function S(t,s,n,o,e){return M(o,s,t,s.length,n,e),s}var v=0;class L extends class{constructor(t,s=3){this.k=s,this.coords=t.slice(),this.index=[...this.coords.keys()].filter(t=>t%2==0),this.index=this.clean(this.index),this.center=this.calcCenter(),this.minY=m(this.coords,this.index),this.minX=function(t,s){let n=0,o=1/0,e=1/0;if(s)for(const[i,r]of s.entries())t[r]<e?(e=t[r],o=t[r+1],n=i):t[r+1]<=o&&t[r]<=e&&(e=t[r],o=t[r+1],n=i);else for(let s=0;s<t.length;s++)t[s]<e&&(e=t[s],n=s);return{x:e,y:o,i:n}}(this.coords,this.index),this.maxX=k(this.coords,this.index),this.cPoints=[],this.ray=null,this.hull=this.findConcaveHull(s)}findConcaveHull(t){const s=this.sortHeapAndClean(this.coords,this.index,"polar",[this.minX.x,this.minY.y],[this.center.x,this.center.y]);return this.concave(s,t)}concave(t,s){const n=t.slice();if(t.length<3)return console.log("len less than 3"),null;if(s>t.length-1)return console.log(v),console.log("k is too big"),null;if(3===t.length)return console.log("len 3"),t;let o=Math.min(Math.max(s,3),t.length-1);const e=m(this.coords,t).i,i={i:e,coord:t[e]};let r=i.coord;const h=[i.coord];let l=1;for(t.splice(i.i,1);(r!==i.coord||1===l)&&t.length>0;){v++,4===l&&t.push(i.coord);const s=this.nearestPoints(t,r,o),e=this.sortByAngle(s,r,h[h.length-2]);let c=!0,a=-1;for(;c&&a<e.length-1;){let t=0;e[a]===i.coord&&(t=1);let s=1;for(c=!1;!c&&s<h.length-t;){const t={x0:this.coords[h[l-1]],y0:this.coords[h[l-1]+1],x1:this.coords[e[a+1]],y1:this.coords[e[a+1]+1]},n={x0:this.coords[h[l-s]],y0:this.coords[h[l-s]+1],x1:this.coords[h[l-1-s]],y1:this.coords[h[l-1-s]+1]},o=g(n,t,!0),r=n.x0===t.x0&&n.y0===t.y0,u=e[a+1]===i.coord&&n.x1===t.x1&&n.y1===t.y1;!isFinite(o.x)||r||u||(c=!0),s++}a++}if(this.cPoints=e.slice(),c)return this.concave(n,++o);if(r=e[a],h.push(r),v>1/0)return h;t.splice(t.indexOf(r),1),l++}let c=!0;for(const s of t)if(c=this.pointInOrOut([this.coords[s],this.coords[s+1]],h,this.maxX.x+10),!c)break;return c?(this.k=o,h):this.concave(n,++o)}sortByAngle(t,s,n){n=n&&n!==s?[this.coords[n],this.coords[n+1]]:[this.maxX.x+10,this.coords[s+1]],this.ray={x0:n[0],y0:n[1],x1:this.coords[s],y1:this.coords[s+1]};const o=[this.coords[s],this.coords[s+1]],e=S(this.coords,t,"polar",n,o).slice();let i,r;for(let t=0;t<e.length;t++){let s=[this.coords[e[t-1]],this.coords[e[t-1]+1]];0===t&&(s=o);const n=[this.coords[e[t]],this.coords[e[t]+1]],h=x(s,n),l=b(o,n);i&&r&&(Math.abs(h)===Math.abs(i)||h===1/0&&i===-1/0)&&l<r?(A(e,t,t-1),r=b(o,[this.coords[e[t]],this.coords[e[t]+1]])):r=l,i=x(s,n)}return e}nearestPoints(t,s,n){const o=[this.coords[s],this.coords[s+1]];t=S(this.coords.slice(),t.slice(),"euclid",o);const e=[];let i;n=Math.min(n,t.length-1);let r=0,h=0;for(;h<n;){const s=x(o,[this.coords[t[r]],this.coords[t[r]+1]]);if(i&&s===i||(e.push(t[r]),h++),r++,r>t.length-1)return e;i=s}return e}sortHeapAndClean(t,s,n,o,e){return s=S(t.slice(),s.slice(),n,o,e),s=this.clean(s)}clean(t){const s=t.length;let n=0;const o=[];for(const s of t){for(let e=0;e<t.length;e++)if(this.coords[t[e]]===this.coords[s]&&this.coords[t[e]+1]===this.coords[s+1]&&n!==e){let n=!0;for(const s of o)this.coords[t[e]]===this.coords[s[0]]&&this.coords[t[e]+1]===this.coords[s[0]+1]&&(n=!1,s[1]++);n&&o.push([s,0]);break}n++}const e=[];for(let s=0;s<t.length;s++){let n=!0;for(const e of o)this.coords[t[s]]===this.coords[e[0]]&&this.coords[t[s]+1]===this.coords[e[0]+1]&&e[1]>0&&(e[1]--,n=!1);n&&e.push(t[s])}return console.log("items removed: "+(s-e.length)),e}calcCenter(){const t={x:0,y:0};for(let s=0;s<this.coords.length;s+=2)t.x+=this.coords[s],t.y+=this.coords[s+1];return t.x/=this.coords.length/2,t.y/=this.coords.length/2,t}pointInOrOut(t,s,n){const o={x0:t[0],y0:t[1],x1:n,y1:t[1]};this.ray=o;let e=0,i={x:1/0,y:1/0};for(let t=0;t<s.length;t++){const n={x0:this.coords[s[t]],y0:this.coords[s[t]+1],x1:this.coords[s[t+1>s.length-1?0:t+1]],y1:this.coords[s[t+1>s.length-1?0:t+1]+1]},r=g(o,n,!0);if(isFinite(r.x)){const t=Math.round(1e6*r.x)===i.x&&Math.round(1e6*r.y)===i.y;n.y1-n.y0>0&&!t?e++:n.y1-n.y0<0&&!t&&e--,i={x:Math.round(1e6*r.x),y:Math.round(1e6*r.y)}}}return 0!==Math.abs(e)}printPoints(t){const s=[];for(const n of t)s.push(this.coords[n],this.coords[n+1]);console.log(s)}get hullCoords(){return this.subset(this.hull)}subset(t){const s=[];for(const n of t)s.push(this.coords[n],this.coords[n+1]);return s}get coords2D(){const t=[],s=this.sortedCoords;for(;s.length;)t.push(s.splice(0,2));return t}get sortedCoords(){const t=[];for(const s of this.hull)t.push(this.coords[s],this.coords[s+1]);return t}}{constructor(t,s=3){super(t,s),this.cPoints=[],this.origCoordsLen=t.length,this.intersectingLineSegs=[]}addPoints(t,s,n){console.log(t,s),this.k=3;const o=function(t){const s=[];for(let n=0;n<t.triangles.length;n++)n>t.halfedges[n]&&s.push(2*t.triangles[n],2*t.triangles[f(n)]);return s}(s);for(let s=0;s<this.hull.length-1;s++){const e=this.subset([this.hull[s],this.hull[s+1]]),i={x0:e[0],y0:e[1],x1:e[2],y1:e[3]},r=this.getIntersectingLines(i,o,t,n).reverse(),h=S(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat(),[...Array(r.length).keys()].map(t=>2*t),"euclid",[i.x0,i.y0]);this.intersectingLineSegs.push(this.hull[s]);const l=this.coords.length;this.coords=this.coords.concat(r.map(t=>[t[t.length-1].x,t[t.length-1].y]).flat()),this.intersectingLineSegs=this.intersectingLineSegs.concat(h.map(t=>t+l))}this.intersectingLineSegs.push(this.intersectingLineSegs[0]),this.hull=this.intersectingLineSegs,this.clean(this.hull)}getIntersectingLines(t,s,n,o,e=null){const i=[];for(let l=0;l<s.length;l+=2){const c={x:n[s[l]],y:n[s[l]+1]};if((r=t,h=c,Math.abs((r.y1-r.y0)*h.x-(r.x1-r.x0)*h.y+r.x1*r.y0-r.y1*r.x0)/Math.sqrt(Math.pow(r.y1-r.y0,2)+Math.pow(r.x1-r.x0,2)))<=o){l+1>s.length-1&&(l=-1);const o=g(t,{x0:c.x,y0:c.y,x1:n[s[l+1]],y1:n[s[l+1]+1]},!1);isFinite(o.x)&&(e&&e([s[l],s[l+1],o]),i.push([s[l],s[l+1],o]))}}var r,h;return i}get k(){return super.k}set k(t){super.k=t}}return class{constructor(t,s,o,...e){if(t&&Array.isArray(t[0])&&2===t[0].length)t=t.flat();else if(t&&Array.isArray(t[0])&&2!==t[0].length)return;this.delaunator=new n(t),this.boundaries=[],this.boundedDelaunators=[];for(let n of e)n&&Array.isArray(n[0])&&2===n[0].length&&(n=n.flat()),this.boundaries.push(new L(n,s)),this.boundaries[this.boundaries.length-1].addPoints(t,this.delaunator,o),this.boundedDelaunators.push(this.setTrianglesInsideBound(this.boundaries[this.boundaries.length-1]));this.boundaries.push(new L(t,s)),this.boundaries[this.boundaries.length-1].addPoints(t,this.delaunator,o),this.boundedDelaunators.push(this.setTrianglesInsideBound(this.boundaries[this.boundaries.length-1])),this.boundary=this.boundaries[this.boundaries.length-1],this.boundedDelaunator=this.boundedDelaunators[this.boundedDelaunators.length-1]}setTrianglesInsideBound(t){let s=[];const o=[...this.delaunator.coords.keys()].filter(t=>t%2==0),e=k(this.delaunator.coords,o);for(const n of o){const o={x:this.delaunator.coords[n],y:this.delaunator.coords[n+1]};t.pointInOrOut([o.x,o.y],t.hull,e.x+10)&&s.push(o.x,o.y)}s=s.concat(t.subset(t.hull));const i=new n(s),r=[];for(let s=0;s<i.triangles.length/3;s++){const n=3*s;let o=0,h=0;for(let t=0;t<3;t++)o+=i.coords[2*i.triangles[t+n]],h+=i.coords[2*i.triangles[t+n]+1];const l={x:o/3,y:h/3};t.pointInOrOut([l.x,l.y],t.hull,e.x+10)&&r.push(i.triangles[n],i.triangles[n+1],i.triangles[n+2])}return i.triangles=new i.triangles.constructor(r),i}update(t){const s=this.coords;for(const n of t.flat())s.push(n);this.delaunator=new n(s)}get coords2D(){const t=[],s=this.coords;for(let n=0;n<s.length;n+=2)t.push([s[n],s[n+1]]);return t}get coords(){return this.delaunator.coords}get triangles(){return this.delaunator.triangles}get hull(){return this.delaunator.hull}}}));
